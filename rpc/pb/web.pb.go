// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: web.proto

package rpcpb

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type TxStatus int32

const (
	TxStatus_unknown   TxStatus = 0
	TxStatus_pending   TxStatus = 1
	TxStatus_onchain   TxStatus = 2
	TxStatus_confirmed TxStatus = 3
)

var TxStatus_name = map[int32]string{
	0: "unknown",
	1: "pending",
	2: "onchain",
	3: "confirmed",
}

var TxStatus_value = map[string]int32{
	"unknown":   0,
	"pending":   1,
	"onchain":   2,
	"confirmed": 3,
}

func (x TxStatus) String() string {
	return proto.EnumName(TxStatus_name, int32(x))
}

func (TxStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{0}
}

type TxOutDetail_TxOutType int32

const (
	TxOutDetail_unknown                 TxOutDetail_TxOutType = 0
	TxOutDetail_pay_to_pubkey_hash      TxOutDetail_TxOutType = 1
	TxOutDetail_pay_to_pubkey_hash_cltv TxOutDetail_TxOutType = 2
	TxOutDetail_token_issue             TxOutDetail_TxOutType = 3
	TxOutDetail_token_transfer          TxOutDetail_TxOutType = 4
	TxOutDetail_new_split_addr          TxOutDetail_TxOutType = 5
	TxOutDetail_pay_to_script_hash      TxOutDetail_TxOutType = 6
	TxOutDetail_contract_create         TxOutDetail_TxOutType = 7
	TxOutDetail_contract_call           TxOutDetail_TxOutType = 8
)

var TxOutDetail_TxOutType_name = map[int32]string{
	0: "unknown",
	1: "pay_to_pubkey_hash",
	2: "pay_to_pubkey_hash_cltv",
	3: "token_issue",
	4: "token_transfer",
	5: "new_split_addr",
	6: "pay_to_script_hash",
	7: "contract_create",
	8: "contract_call",
}

var TxOutDetail_TxOutType_value = map[string]int32{
	"unknown":                 0,
	"pay_to_pubkey_hash":      1,
	"pay_to_pubkey_hash_cltv": 2,
	"token_issue":             3,
	"token_transfer":          4,
	"new_split_addr":          5,
	"pay_to_script_hash":      6,
	"contract_create":         7,
	"contract_call":           8,
}

func (x TxOutDetail_TxOutType) String() string {
	return proto.EnumName(TxOutDetail_TxOutType_name, int32(x))
}

func (TxOutDetail_TxOutType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{15, 0}
}

type RegisterReq struct {
	Type   uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Cancel bool   `protobuf:"varint,2,opt,name=cancel,proto3" json:"cancel,omitempty"`
	// Types that are valid to be assigned to Info:
	//	*RegisterReq_LogsReq
	Info isRegisterReq_Info `protobuf_oneof:"info"`
}

func (m *RegisterReq) Reset()         { *m = RegisterReq{} }
func (m *RegisterReq) String() string { return proto.CompactTextString(m) }
func (*RegisterReq) ProtoMessage()    {}
func (*RegisterReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{0}
}
func (m *RegisterReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterReq.Merge(m, src)
}
func (m *RegisterReq) XXX_Size() int {
	return m.Size()
}
func (m *RegisterReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterReq.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterReq proto.InternalMessageInfo

type isRegisterReq_Info interface {
	isRegisterReq_Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RegisterReq_LogsReq struct {
	LogsReq *LogsReq `protobuf:"bytes,3,opt,name=logs_req,json=logsReq,proto3,oneof"`
}

func (*RegisterReq_LogsReq) isRegisterReq_Info() {}

func (m *RegisterReq) GetInfo() isRegisterReq_Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *RegisterReq) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RegisterReq) GetCancel() bool {
	if m != nil {
		return m.Cancel
	}
	return false
}

func (m *RegisterReq) GetLogsReq() *LogsReq {
	if x, ok := m.GetInfo().(*RegisterReq_LogsReq); ok {
		return x.LogsReq
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RegisterReq) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RegisterReq_OneofMarshaler, _RegisterReq_OneofUnmarshaler, _RegisterReq_OneofSizer, []interface{}{
		(*RegisterReq_LogsReq)(nil),
	}
}

func _RegisterReq_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RegisterReq)
	// info
	switch x := m.Info.(type) {
	case *RegisterReq_LogsReq:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogsReq); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RegisterReq.Info has unexpected type %T", x)
	}
	return nil
}

func _RegisterReq_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RegisterReq)
	switch tag {
	case 3: // info.logs_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogsReq)
		err := b.DecodeMessage(msg)
		m.Info = &RegisterReq_LogsReq{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RegisterReq_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RegisterReq)
	// info
	switch x := m.Info.(type) {
	case *RegisterReq_LogsReq:
		s := proto.Size(x.LogsReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListenedData struct {
	Type uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*ListenedData_Block
	//	*ListenedData_Logs
	//	*ListenedData_Info
	Data isListenedData_Data `protobuf_oneof:"data"`
}

func (m *ListenedData) Reset()         { *m = ListenedData{} }
func (m *ListenedData) String() string { return proto.CompactTextString(m) }
func (*ListenedData) ProtoMessage()    {}
func (*ListenedData) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{1}
}
func (m *ListenedData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListenedData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListenedData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListenedData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListenedData.Merge(m, src)
}
func (m *ListenedData) XXX_Size() int {
	return m.Size()
}
func (m *ListenedData) XXX_DiscardUnknown() {
	xxx_messageInfo_ListenedData.DiscardUnknown(m)
}

var xxx_messageInfo_ListenedData proto.InternalMessageInfo

type isListenedData_Data interface {
	isListenedData_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListenedData_Block struct {
	Block *BlockDetail `protobuf:"bytes,2,opt,name=block,proto3,oneof"`
}
type ListenedData_Logs struct {
	Logs *LogDetails `protobuf:"bytes,3,opt,name=logs,proto3,oneof"`
}
type ListenedData_Info struct {
	Info *RegisterDetails `protobuf:"bytes,4,opt,name=info,proto3,oneof"`
}

func (*ListenedData_Block) isListenedData_Data() {}
func (*ListenedData_Logs) isListenedData_Data()  {}
func (*ListenedData_Info) isListenedData_Data()  {}

func (m *ListenedData) GetData() isListenedData_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ListenedData) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ListenedData) GetBlock() *BlockDetail {
	if x, ok := m.GetData().(*ListenedData_Block); ok {
		return x.Block
	}
	return nil
}

func (m *ListenedData) GetLogs() *LogDetails {
	if x, ok := m.GetData().(*ListenedData_Logs); ok {
		return x.Logs
	}
	return nil
}

func (m *ListenedData) GetInfo() *RegisterDetails {
	if x, ok := m.GetData().(*ListenedData_Info); ok {
		return x.Info
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListenedData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListenedData_OneofMarshaler, _ListenedData_OneofUnmarshaler, _ListenedData_OneofSizer, []interface{}{
		(*ListenedData_Block)(nil),
		(*ListenedData_Logs)(nil),
		(*ListenedData_Info)(nil),
	}
}

func _ListenedData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListenedData)
	// data
	switch x := m.Data.(type) {
	case *ListenedData_Block:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Block); err != nil {
			return err
		}
	case *ListenedData_Logs:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Logs); err != nil {
			return err
		}
	case *ListenedData_Info:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Info); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ListenedData.Data has unexpected type %T", x)
	}
	return nil
}

func _ListenedData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListenedData)
	switch tag {
	case 2: // data.block
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BlockDetail)
		err := b.DecodeMessage(msg)
		m.Data = &ListenedData_Block{msg}
		return true, err
	case 3: // data.logs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogDetails)
		err := b.DecodeMessage(msg)
		m.Data = &ListenedData_Logs{msg}
		return true, err
	case 4: // data.info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RegisterDetails)
		err := b.DecodeMessage(msg)
		m.Data = &ListenedData_Info{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ListenedData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListenedData)
	// data
	switch x := m.Data.(type) {
	case *ListenedData_Block:
		s := proto.Size(x.Block)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ListenedData_Logs:
		s := proto.Size(x.Logs)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ListenedData_Info:
		s := proto.Size(x.Info)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RegisterDetails struct {
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *RegisterDetails) Reset()         { *m = RegisterDetails{} }
func (m *RegisterDetails) String() string { return proto.CompactTextString(m) }
func (*RegisterDetails) ProtoMessage()    {}
func (*RegisterDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{2}
}
func (m *RegisterDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterDetails.Merge(m, src)
}
func (m *RegisterDetails) XXX_Size() int {
	return m.Size()
}
func (m *RegisterDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterDetails.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterDetails proto.InternalMessageInfo

func (m *RegisterDetails) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

type ViewTxDetailReq struct {
	Hash        string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	SpreadSplit bool   `protobuf:"varint,2,opt,name=spread_split,json=spreadSplit,proto3" json:"spread_split,omitempty"`
}

func (m *ViewTxDetailReq) Reset()         { *m = ViewTxDetailReq{} }
func (m *ViewTxDetailReq) String() string { return proto.CompactTextString(m) }
func (*ViewTxDetailReq) ProtoMessage()    {}
func (*ViewTxDetailReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{3}
}
func (m *ViewTxDetailReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewTxDetailReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewTxDetailReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewTxDetailReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewTxDetailReq.Merge(m, src)
}
func (m *ViewTxDetailReq) XXX_Size() int {
	return m.Size()
}
func (m *ViewTxDetailReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewTxDetailReq.DiscardUnknown(m)
}

var xxx_messageInfo_ViewTxDetailReq proto.InternalMessageInfo

func (m *ViewTxDetailReq) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ViewTxDetailReq) GetSpreadSplit() bool {
	if m != nil {
		return m.SpreadSplit
	}
	return false
}

type ViewTxDetailResp struct {
	Code        int32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message     string    `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Version     int32     `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	BlockTime   int64     `protobuf:"varint,4,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
	BlockHeight uint32    `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	Status      TxStatus  `protobuf:"varint,6,opt,name=status,proto3,enum=rpcpb.TxStatus" json:"status,omitempty"`
	Detail      *TxDetail `protobuf:"bytes,7,opt,name=detail,proto3" json:"detail,omitempty"`
}

func (m *ViewTxDetailResp) Reset()         { *m = ViewTxDetailResp{} }
func (m *ViewTxDetailResp) String() string { return proto.CompactTextString(m) }
func (*ViewTxDetailResp) ProtoMessage()    {}
func (*ViewTxDetailResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{4}
}
func (m *ViewTxDetailResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewTxDetailResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewTxDetailResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewTxDetailResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewTxDetailResp.Merge(m, src)
}
func (m *ViewTxDetailResp) XXX_Size() int {
	return m.Size()
}
func (m *ViewTxDetailResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewTxDetailResp.DiscardUnknown(m)
}

var xxx_messageInfo_ViewTxDetailResp proto.InternalMessageInfo

func (m *ViewTxDetailResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ViewTxDetailResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ViewTxDetailResp) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ViewTxDetailResp) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *ViewTxDetailResp) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ViewTxDetailResp) GetStatus() TxStatus {
	if m != nil {
		return m.Status
	}
	return TxStatus_unknown
}

func (m *ViewTxDetailResp) GetDetail() *TxDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

type ViewBlockDetailReq struct {
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *ViewBlockDetailReq) Reset()         { *m = ViewBlockDetailReq{} }
func (m *ViewBlockDetailReq) String() string { return proto.CompactTextString(m) }
func (*ViewBlockDetailReq) ProtoMessage()    {}
func (*ViewBlockDetailReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{5}
}
func (m *ViewBlockDetailReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewBlockDetailReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewBlockDetailReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewBlockDetailReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewBlockDetailReq.Merge(m, src)
}
func (m *ViewBlockDetailReq) XXX_Size() int {
	return m.Size()
}
func (m *ViewBlockDetailReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewBlockDetailReq.DiscardUnknown(m)
}

var xxx_messageInfo_ViewBlockDetailReq proto.InternalMessageInfo

func (m *ViewBlockDetailReq) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type ViewBlockDetailResp struct {
	Code    int32        `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Detail  *BlockDetail `protobuf:"bytes,3,opt,name=detail,proto3" json:"detail,omitempty"`
}

func (m *ViewBlockDetailResp) Reset()         { *m = ViewBlockDetailResp{} }
func (m *ViewBlockDetailResp) String() string { return proto.CompactTextString(m) }
func (*ViewBlockDetailResp) ProtoMessage()    {}
func (*ViewBlockDetailResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{6}
}
func (m *ViewBlockDetailResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewBlockDetailResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewBlockDetailResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewBlockDetailResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewBlockDetailResp.Merge(m, src)
}
func (m *ViewBlockDetailResp) XXX_Size() int {
	return m.Size()
}
func (m *ViewBlockDetailResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewBlockDetailResp.DiscardUnknown(m)
}

var xxx_messageInfo_ViewBlockDetailResp proto.InternalMessageInfo

func (m *ViewBlockDetailResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ViewBlockDetailResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ViewBlockDetailResp) GetDetail() *BlockDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

type ContractInfo struct {
	Fee      uint32       `protobuf:"varint,1,opt,name=fee,proto3" json:"fee,omitempty"`
	Failed   bool         `protobuf:"varint,2,opt,name=failed,proto3" json:"failed,omitempty"`
	GasLimit uint64       `protobuf:"varint,3,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	GasUsed  uint64       `protobuf:"varint,4,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	GasPrice uint64       `protobuf:"varint,5,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	Nonce    uint64       `protobuf:"varint,6,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Data     string       `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`
	Logs     []*LogDetail `protobuf:"bytes,8,rep,name=logs,proto3" json:"logs,omitempty"`
}

func (m *ContractInfo) Reset()         { *m = ContractInfo{} }
func (m *ContractInfo) String() string { return proto.CompactTextString(m) }
func (*ContractInfo) ProtoMessage()    {}
func (*ContractInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{7}
}
func (m *ContractInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractInfo.Merge(m, src)
}
func (m *ContractInfo) XXX_Size() int {
	return m.Size()
}
func (m *ContractInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ContractInfo proto.InternalMessageInfo

func (m *ContractInfo) GetFee() uint32 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *ContractInfo) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *ContractInfo) GetGasLimit() uint64 {
	if m != nil {
		return m.GasLimit
	}
	return 0
}

func (m *ContractInfo) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

func (m *ContractInfo) GetGasPrice() uint64 {
	if m != nil {
		return m.GasPrice
	}
	return 0
}

func (m *ContractInfo) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ContractInfo) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *ContractInfo) GetLogs() []*LogDetail {
	if m != nil {
		return m.Logs
	}
	return nil
}

type ListenBlocksReq struct {
}

func (m *ListenBlocksReq) Reset()         { *m = ListenBlocksReq{} }
func (m *ListenBlocksReq) String() string { return proto.CompactTextString(m) }
func (*ListenBlocksReq) ProtoMessage()    {}
func (*ListenBlocksReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{8}
}
func (m *ListenBlocksReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListenBlocksReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListenBlocksReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListenBlocksReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListenBlocksReq.Merge(m, src)
}
func (m *ListenBlocksReq) XXX_Size() int {
	return m.Size()
}
func (m *ListenBlocksReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListenBlocksReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListenBlocksReq proto.InternalMessageInfo

type LogsReq struct {
	Uid       string              `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Hash      string              `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	From      uint32              `protobuf:"varint,3,opt,name=from,proto3" json:"from,omitempty"`
	To        uint32              `protobuf:"varint,4,opt,name=to,proto3" json:"to,omitempty"`
	Addresses []string            `protobuf:"bytes,5,rep,name=addresses,proto3" json:"addresses,omitempty"`
	Topics    []*LogsReqTopiclist `protobuf:"bytes,6,rep,name=topics,proto3" json:"topics,omitempty"`
}

func (m *LogsReq) Reset()         { *m = LogsReq{} }
func (m *LogsReq) String() string { return proto.CompactTextString(m) }
func (*LogsReq) ProtoMessage()    {}
func (*LogsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{9}
}
func (m *LogsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogsReq.Merge(m, src)
}
func (m *LogsReq) XXX_Size() int {
	return m.Size()
}
func (m *LogsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LogsReq.DiscardUnknown(m)
}

var xxx_messageInfo_LogsReq proto.InternalMessageInfo

func (m *LogsReq) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *LogsReq) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *LogsReq) GetFrom() uint32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *LogsReq) GetTo() uint32 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *LogsReq) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *LogsReq) GetTopics() []*LogsReqTopiclist {
	if m != nil {
		return m.Topics
	}
	return nil
}

type LogsReqTopiclist struct {
	Topics []string `protobuf:"bytes,1,rep,name=topics,proto3" json:"topics,omitempty"`
}

func (m *LogsReqTopiclist) Reset()         { *m = LogsReqTopiclist{} }
func (m *LogsReqTopiclist) String() string { return proto.CompactTextString(m) }
func (*LogsReqTopiclist) ProtoMessage()    {}
func (*LogsReqTopiclist) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{9, 0}
}
func (m *LogsReqTopiclist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogsReqTopiclist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogsReqTopiclist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogsReqTopiclist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogsReqTopiclist.Merge(m, src)
}
func (m *LogsReqTopiclist) XXX_Size() int {
	return m.Size()
}
func (m *LogsReqTopiclist) XXX_DiscardUnknown() {
	xxx_messageInfo_LogsReqTopiclist.DiscardUnknown(m)
}

var xxx_messageInfo_LogsReqTopiclist proto.InternalMessageInfo

func (m *LogsReqTopiclist) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

type Logs struct {
	Code    int32        `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Logs    []*LogDetail `protobuf:"bytes,3,rep,name=logs,proto3" json:"logs,omitempty"`
}

func (m *Logs) Reset()         { *m = Logs{} }
func (m *Logs) String() string { return proto.CompactTextString(m) }
func (*Logs) ProtoMessage()    {}
func (*Logs) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{10}
}
func (m *Logs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Logs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Logs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Logs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Logs.Merge(m, src)
}
func (m *Logs) XXX_Size() int {
	return m.Size()
}
func (m *Logs) XXX_DiscardUnknown() {
	xxx_messageInfo_Logs.DiscardUnknown(m)
}

var xxx_messageInfo_Logs proto.InternalMessageInfo

func (m *Logs) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Logs) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Logs) GetLogs() []*LogDetail {
	if m != nil {
		return m.Logs
	}
	return nil
}

type LogDetails struct {
	Logs []*LogDetail `protobuf:"bytes,1,rep,name=logs,proto3" json:"logs,omitempty"`
}

func (m *LogDetails) Reset()         { *m = LogDetails{} }
func (m *LogDetails) String() string { return proto.CompactTextString(m) }
func (*LogDetails) ProtoMessage()    {}
func (*LogDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{11}
}
func (m *LogDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogDetails.Merge(m, src)
}
func (m *LogDetails) XXX_Size() int {
	return m.Size()
}
func (m *LogDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_LogDetails.DiscardUnknown(m)
}

var xxx_messageInfo_LogDetails proto.InternalMessageInfo

func (m *LogDetails) GetLogs() []*LogDetail {
	if m != nil {
		return m.Logs
	}
	return nil
}

type LogDetail struct {
	Address     string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Topics      []string `protobuf:"bytes,2,rep,name=topics,proto3" json:"topics,omitempty"`
	Data        string   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	BlockNumber uint64   `protobuf:"varint,4,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	TxHash      string   `protobuf:"bytes,5,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	TxIndex     uint32   `protobuf:"varint,6,opt,name=tx_index,json=txIndex,proto3" json:"tx_index,omitempty"`
	BlockHash   string   `protobuf:"bytes,7,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	Index       uint32   `protobuf:"varint,8,opt,name=index,proto3" json:"index,omitempty"`
	Removed     bool     `protobuf:"varint,9,opt,name=removed,proto3" json:"removed,omitempty"`
}

func (m *LogDetail) Reset()         { *m = LogDetail{} }
func (m *LogDetail) String() string { return proto.CompactTextString(m) }
func (*LogDetail) ProtoMessage()    {}
func (*LogDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{12}
}
func (m *LogDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogDetail.Merge(m, src)
}
func (m *LogDetail) XXX_Size() int {
	return m.Size()
}
func (m *LogDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_LogDetail.DiscardUnknown(m)
}

var xxx_messageInfo_LogDetail proto.InternalMessageInfo

func (m *LogDetail) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *LogDetail) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

func (m *LogDetail) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *LogDetail) GetBlockNumber() uint64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *LogDetail) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *LogDetail) GetTxIndex() uint32 {
	if m != nil {
		return m.TxIndex
	}
	return 0
}

func (m *LogDetail) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *LogDetail) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *LogDetail) GetRemoved() bool {
	if m != nil {
		return m.Removed
	}
	return false
}

type TxDetail struct {
	Hash string         `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Vin  []*TxInDetail  `protobuf:"bytes,2,rep,name=vin,proto3" json:"vin,omitempty"`
	Vout []*TxOutDetail `protobuf:"bytes,3,rep,name=vout,proto3" json:"vout,omitempty"`
}

func (m *TxDetail) Reset()         { *m = TxDetail{} }
func (m *TxDetail) String() string { return proto.CompactTextString(m) }
func (*TxDetail) ProtoMessage()    {}
func (*TxDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{13}
}
func (m *TxDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxDetail.Merge(m, src)
}
func (m *TxDetail) XXX_Size() int {
	return m.Size()
}
func (m *TxDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TxDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TxDetail proto.InternalMessageInfo

func (m *TxDetail) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *TxDetail) GetVin() []*TxInDetail {
	if m != nil {
		return m.Vin
	}
	return nil
}

func (m *TxDetail) GetVout() []*TxOutDetail {
	if m != nil {
		return m.Vout
	}
	return nil
}

type TxInDetail struct {
	PrevOutDetail *TxOutDetail `protobuf:"bytes,1,opt,name=prev_out_detail,json=prevOutDetail,proto3" json:"prev_out_detail,omitempty"`
	ScriptSig     string       `protobuf:"bytes,2,opt,name=script_sig,json=scriptSig,proto3" json:"script_sig,omitempty"`
	Sequence      uint32       `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	PrevOutPoint  string       `protobuf:"bytes,4,opt,name=prev_out_point,json=prevOutPoint,proto3" json:"prev_out_point,omitempty"`
}

func (m *TxInDetail) Reset()         { *m = TxInDetail{} }
func (m *TxInDetail) String() string { return proto.CompactTextString(m) }
func (*TxInDetail) ProtoMessage()    {}
func (*TxInDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{14}
}
func (m *TxInDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxInDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxInDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxInDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxInDetail.Merge(m, src)
}
func (m *TxInDetail) XXX_Size() int {
	return m.Size()
}
func (m *TxInDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TxInDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TxInDetail proto.InternalMessageInfo

func (m *TxInDetail) GetPrevOutDetail() *TxOutDetail {
	if m != nil {
		return m.PrevOutDetail
	}
	return nil
}

func (m *TxInDetail) GetScriptSig() string {
	if m != nil {
		return m.ScriptSig
	}
	return ""
}

func (m *TxInDetail) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *TxInDetail) GetPrevOutPoint() string {
	if m != nil {
		return m.PrevOutPoint
	}
	return ""
}

type TxOutDetail struct {
	Addr         string                `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Value        uint64                `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	ScriptPubKey string                `protobuf:"bytes,3,opt,name=script_pub_key,json=scriptPubKey,proto3" json:"script_pub_key,omitempty"`
	ScriptDisasm string                `protobuf:"bytes,4,opt,name=script_disasm,json=scriptDisasm,proto3" json:"script_disasm,omitempty"`
	Type         TxOutDetail_TxOutType `protobuf:"varint,5,opt,name=type,proto3,enum=rpcpb.TxOutDetail_TxOutType" json:"type,omitempty"`
	// Types that are valid to be assigned to Appendix:
	//	*TxOutDetail_TokenIssueInfo
	//	*TxOutDetail_TokenTransferInfo
	//	*TxOutDetail_SplitContractInfo
	//	*TxOutDetail_ContractInfo
	Appendix isTxOutDetail_Appendix `protobuf_oneof:"appendix"`
}

func (m *TxOutDetail) Reset()         { *m = TxOutDetail{} }
func (m *TxOutDetail) String() string { return proto.CompactTextString(m) }
func (*TxOutDetail) ProtoMessage()    {}
func (*TxOutDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{15}
}
func (m *TxOutDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxOutDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxOutDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxOutDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxOutDetail.Merge(m, src)
}
func (m *TxOutDetail) XXX_Size() int {
	return m.Size()
}
func (m *TxOutDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TxOutDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TxOutDetail proto.InternalMessageInfo

type isTxOutDetail_Appendix interface {
	isTxOutDetail_Appendix()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TxOutDetail_TokenIssueInfo struct {
	TokenIssueInfo *TokenIssueInfo `protobuf:"bytes,6,opt,name=token_issue_info,json=tokenIssueInfo,proto3,oneof"`
}
type TxOutDetail_TokenTransferInfo struct {
	TokenTransferInfo *TokenTransferInfo `protobuf:"bytes,7,opt,name=token_transfer_info,json=tokenTransferInfo,proto3,oneof"`
}
type TxOutDetail_SplitContractInfo struct {
	SplitContractInfo *SplitContractInfo `protobuf:"bytes,8,opt,name=split_contract_info,json=splitContractInfo,proto3,oneof"`
}
type TxOutDetail_ContractInfo struct {
	ContractInfo *ContractInfo `protobuf:"bytes,9,opt,name=contract_info,json=contractInfo,proto3,oneof"`
}

func (*TxOutDetail_TokenIssueInfo) isTxOutDetail_Appendix()    {}
func (*TxOutDetail_TokenTransferInfo) isTxOutDetail_Appendix() {}
func (*TxOutDetail_SplitContractInfo) isTxOutDetail_Appendix() {}
func (*TxOutDetail_ContractInfo) isTxOutDetail_Appendix()      {}

func (m *TxOutDetail) GetAppendix() isTxOutDetail_Appendix {
	if m != nil {
		return m.Appendix
	}
	return nil
}

func (m *TxOutDetail) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *TxOutDetail) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *TxOutDetail) GetScriptPubKey() string {
	if m != nil {
		return m.ScriptPubKey
	}
	return ""
}

func (m *TxOutDetail) GetScriptDisasm() string {
	if m != nil {
		return m.ScriptDisasm
	}
	return ""
}

func (m *TxOutDetail) GetType() TxOutDetail_TxOutType {
	if m != nil {
		return m.Type
	}
	return TxOutDetail_unknown
}

func (m *TxOutDetail) GetTokenIssueInfo() *TokenIssueInfo {
	if x, ok := m.GetAppendix().(*TxOutDetail_TokenIssueInfo); ok {
		return x.TokenIssueInfo
	}
	return nil
}

func (m *TxOutDetail) GetTokenTransferInfo() *TokenTransferInfo {
	if x, ok := m.GetAppendix().(*TxOutDetail_TokenTransferInfo); ok {
		return x.TokenTransferInfo
	}
	return nil
}

func (m *TxOutDetail) GetSplitContractInfo() *SplitContractInfo {
	if x, ok := m.GetAppendix().(*TxOutDetail_SplitContractInfo); ok {
		return x.SplitContractInfo
	}
	return nil
}

func (m *TxOutDetail) GetContractInfo() *ContractInfo {
	if x, ok := m.GetAppendix().(*TxOutDetail_ContractInfo); ok {
		return x.ContractInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TxOutDetail) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TxOutDetail_OneofMarshaler, _TxOutDetail_OneofUnmarshaler, _TxOutDetail_OneofSizer, []interface{}{
		(*TxOutDetail_TokenIssueInfo)(nil),
		(*TxOutDetail_TokenTransferInfo)(nil),
		(*TxOutDetail_SplitContractInfo)(nil),
		(*TxOutDetail_ContractInfo)(nil),
	}
}

func _TxOutDetail_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TxOutDetail)
	// appendix
	switch x := m.Appendix.(type) {
	case *TxOutDetail_TokenIssueInfo:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TokenIssueInfo); err != nil {
			return err
		}
	case *TxOutDetail_TokenTransferInfo:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TokenTransferInfo); err != nil {
			return err
		}
	case *TxOutDetail_SplitContractInfo:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SplitContractInfo); err != nil {
			return err
		}
	case *TxOutDetail_ContractInfo:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContractInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TxOutDetail.Appendix has unexpected type %T", x)
	}
	return nil
}

func _TxOutDetail_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TxOutDetail)
	switch tag {
	case 6: // appendix.token_issue_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TokenIssueInfo)
		err := b.DecodeMessage(msg)
		m.Appendix = &TxOutDetail_TokenIssueInfo{msg}
		return true, err
	case 7: // appendix.token_transfer_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TokenTransferInfo)
		err := b.DecodeMessage(msg)
		m.Appendix = &TxOutDetail_TokenTransferInfo{msg}
		return true, err
	case 8: // appendix.split_contract_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SplitContractInfo)
		err := b.DecodeMessage(msg)
		m.Appendix = &TxOutDetail_SplitContractInfo{msg}
		return true, err
	case 9: // appendix.contract_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContractInfo)
		err := b.DecodeMessage(msg)
		m.Appendix = &TxOutDetail_ContractInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TxOutDetail_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TxOutDetail)
	// appendix
	switch x := m.Appendix.(type) {
	case *TxOutDetail_TokenIssueInfo:
		s := proto.Size(x.TokenIssueInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TxOutDetail_TokenTransferInfo:
		s := proto.Size(x.TokenTransferInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TxOutDetail_SplitContractInfo:
		s := proto.Size(x.SplitContractInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TxOutDetail_ContractInfo:
		s := proto.Size(x.ContractInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type BlockDetail struct {
	Version       int32       `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Height        uint32      `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TimeStamp     int64       `protobuf:"varint,3,opt,name=time_stamp,json=timeStamp,proto3" json:"time_stamp,omitempty"`
	Size_         uint32      `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	Hash          string      `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
	PrevBlockHash string      `protobuf:"bytes,6,opt,name=prev_block_hash,json=prevBlockHash,proto3" json:"prev_block_hash,omitempty"`
	CoinBase      string      `protobuf:"bytes,7,opt,name=coin_base,json=coinBase,proto3" json:"coin_base,omitempty"`
	Confirmed     bool        `protobuf:"varint,8,opt,name=confirmed,proto3" json:"confirmed,omitempty"`
	Signature     string      `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty"`
	Txs           []*TxDetail `protobuf:"bytes,10,rep,name=txs,proto3" json:"txs,omitempty"`
}

func (m *BlockDetail) Reset()         { *m = BlockDetail{} }
func (m *BlockDetail) String() string { return proto.CompactTextString(m) }
func (*BlockDetail) ProtoMessage()    {}
func (*BlockDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{16}
}
func (m *BlockDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockDetail.Merge(m, src)
}
func (m *BlockDetail) XXX_Size() int {
	return m.Size()
}
func (m *BlockDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockDetail.DiscardUnknown(m)
}

var xxx_messageInfo_BlockDetail proto.InternalMessageInfo

func (m *BlockDetail) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BlockDetail) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BlockDetail) GetTimeStamp() int64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

func (m *BlockDetail) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *BlockDetail) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *BlockDetail) GetPrevBlockHash() string {
	if m != nil {
		return m.PrevBlockHash
	}
	return ""
}

func (m *BlockDetail) GetCoinBase() string {
	if m != nil {
		return m.CoinBase
	}
	return ""
}

func (m *BlockDetail) GetConfirmed() bool {
	if m != nil {
		return m.Confirmed
	}
	return false
}

func (m *BlockDetail) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *BlockDetail) GetTxs() []*TxDetail {
	if m != nil {
		return m.Txs
	}
	return nil
}

type TokenIssueInfo struct {
	TokenTag *TokenTag `protobuf:"bytes,1,opt,name=token_tag,json=tokenTag,proto3" json:"token_tag,omitempty"`
}

func (m *TokenIssueInfo) Reset()         { *m = TokenIssueInfo{} }
func (m *TokenIssueInfo) String() string { return proto.CompactTextString(m) }
func (*TokenIssueInfo) ProtoMessage()    {}
func (*TokenIssueInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{17}
}
func (m *TokenIssueInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenIssueInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenIssueInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenIssueInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenIssueInfo.Merge(m, src)
}
func (m *TokenIssueInfo) XXX_Size() int {
	return m.Size()
}
func (m *TokenIssueInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenIssueInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TokenIssueInfo proto.InternalMessageInfo

func (m *TokenIssueInfo) GetTokenTag() *TokenTag {
	if m != nil {
		return m.TokenTag
	}
	return nil
}

type SplitContractInfo struct {
	Addrs   []string `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"`
	Weights []uint32 `protobuf:"varint,2,rep,packed,name=weights,proto3" json:"weights,omitempty"`
}

func (m *SplitContractInfo) Reset()         { *m = SplitContractInfo{} }
func (m *SplitContractInfo) String() string { return proto.CompactTextString(m) }
func (*SplitContractInfo) ProtoMessage()    {}
func (*SplitContractInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{18}
}
func (m *SplitContractInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitContractInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitContractInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitContractInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitContractInfo.Merge(m, src)
}
func (m *SplitContractInfo) XXX_Size() int {
	return m.Size()
}
func (m *SplitContractInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitContractInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SplitContractInfo proto.InternalMessageInfo

func (m *SplitContractInfo) GetAddrs() []string {
	if m != nil {
		return m.Addrs
	}
	return nil
}

func (m *SplitContractInfo) GetWeights() []uint32 {
	if m != nil {
		return m.Weights
	}
	return nil
}

type TokenTransferInfo struct {
	TokenId string `protobuf:"bytes,1,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
}

func (m *TokenTransferInfo) Reset()         { *m = TokenTransferInfo{} }
func (m *TokenTransferInfo) String() string { return proto.CompactTextString(m) }
func (*TokenTransferInfo) ProtoMessage()    {}
func (*TokenTransferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{19}
}
func (m *TokenTransferInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenTransferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenTransferInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenTransferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenTransferInfo.Merge(m, src)
}
func (m *TokenTransferInfo) XXX_Size() int {
	return m.Size()
}
func (m *TokenTransferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenTransferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TokenTransferInfo proto.InternalMessageInfo

func (m *TokenTransferInfo) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

type CallReq struct {
	From    string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	To      string `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	Data    string `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Height  uint32 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	Timeout uint32 `protobuf:"varint,5,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *CallReq) Reset()         { *m = CallReq{} }
func (m *CallReq) String() string { return proto.CompactTextString(m) }
func (*CallReq) ProtoMessage()    {}
func (*CallReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{20}
}
func (m *CallReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallReq.Merge(m, src)
}
func (m *CallReq) XXX_Size() int {
	return m.Size()
}
func (m *CallReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CallReq.DiscardUnknown(m)
}

var xxx_messageInfo_CallReq proto.InternalMessageInfo

func (m *CallReq) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *CallReq) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *CallReq) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *CallReq) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *CallReq) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type CallResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Output  string `protobuf:"bytes,3,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *CallResp) Reset()         { *m = CallResp{} }
func (m *CallResp) String() string { return proto.CompactTextString(m) }
func (*CallResp) ProtoMessage()    {}
func (*CallResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{21}
}
func (m *CallResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallResp.Merge(m, src)
}
func (m *CallResp) XXX_Size() int {
	return m.Size()
}
func (m *CallResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CallResp.DiscardUnknown(m)
}

var xxx_messageInfo_CallResp proto.InternalMessageInfo

func (m *CallResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CallResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *CallResp) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

type NonceReq struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *NonceReq) Reset()         { *m = NonceReq{} }
func (m *NonceReq) String() string { return proto.CompactTextString(m) }
func (*NonceReq) ProtoMessage()    {}
func (*NonceReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{22}
}
func (m *NonceReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NonceReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NonceReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NonceReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NonceReq.Merge(m, src)
}
func (m *NonceReq) XXX_Size() int {
	return m.Size()
}
func (m *NonceReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NonceReq.DiscardUnknown(m)
}

var xxx_messageInfo_NonceReq proto.InternalMessageInfo

func (m *NonceReq) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type NonceResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Nonce   uint64 `protobuf:"varint,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *NonceResp) Reset()         { *m = NonceResp{} }
func (m *NonceResp) String() string { return proto.CompactTextString(m) }
func (*NonceResp) ProtoMessage()    {}
func (*NonceResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{23}
}
func (m *NonceResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NonceResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NonceResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NonceResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NonceResp.Merge(m, src)
}
func (m *NonceResp) XXX_Size() int {
	return m.Size()
}
func (m *NonceResp) XXX_DiscardUnknown() {
	xxx_messageInfo_NonceResp.DiscardUnknown(m)
}

var xxx_messageInfo_NonceResp proto.InternalMessageInfo

func (m *NonceResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *NonceResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *NonceResp) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type TableReq struct {
}

func (m *TableReq) Reset()         { *m = TableReq{} }
func (m *TableReq) String() string { return proto.CompactTextString(m) }
func (*TableReq) ProtoMessage()    {}
func (*TableReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{24}
}
func (m *TableReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableReq.Merge(m, src)
}
func (m *TableReq) XXX_Size() int {
	return m.Size()
}
func (m *TableReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TableReq.DiscardUnknown(m)
}

var xxx_messageInfo_TableReq proto.InternalMessageInfo

type TableResp struct {
	Table []string `protobuf:"bytes,1,rep,name=table,proto3" json:"table,omitempty"`
}

func (m *TableResp) Reset()         { *m = TableResp{} }
func (m *TableResp) String() string { return proto.CompactTextString(m) }
func (*TableResp) ProtoMessage()    {}
func (*TableResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{25}
}
func (m *TableResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableResp.Merge(m, src)
}
func (m *TableResp) XXX_Size() int {
	return m.Size()
}
func (m *TableResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TableResp.DiscardUnknown(m)
}

var xxx_messageInfo_TableResp proto.InternalMessageInfo

func (m *TableResp) GetTable() []string {
	if m != nil {
		return m.Table
	}
	return nil
}

func init() {
	proto.RegisterEnum("rpcpb.TxStatus", TxStatus_name, TxStatus_value)
	proto.RegisterEnum("rpcpb.TxOutDetail_TxOutType", TxOutDetail_TxOutType_name, TxOutDetail_TxOutType_value)
	proto.RegisterType((*RegisterReq)(nil), "rpcpb.RegisterReq")
	proto.RegisterType((*ListenedData)(nil), "rpcpb.ListenedData")
	proto.RegisterType((*RegisterDetails)(nil), "rpcpb.RegisterDetails")
	proto.RegisterType((*ViewTxDetailReq)(nil), "rpcpb.ViewTxDetailReq")
	proto.RegisterType((*ViewTxDetailResp)(nil), "rpcpb.ViewTxDetailResp")
	proto.RegisterType((*ViewBlockDetailReq)(nil), "rpcpb.ViewBlockDetailReq")
	proto.RegisterType((*ViewBlockDetailResp)(nil), "rpcpb.ViewBlockDetailResp")
	proto.RegisterType((*ContractInfo)(nil), "rpcpb.ContractInfo")
	proto.RegisterType((*ListenBlocksReq)(nil), "rpcpb.ListenBlocksReq")
	proto.RegisterType((*LogsReq)(nil), "rpcpb.LogsReq")
	proto.RegisterType((*LogsReqTopiclist)(nil), "rpcpb.LogsReq.topiclist")
	proto.RegisterType((*Logs)(nil), "rpcpb.Logs")
	proto.RegisterType((*LogDetails)(nil), "rpcpb.LogDetails")
	proto.RegisterType((*LogDetail)(nil), "rpcpb.LogDetail")
	proto.RegisterType((*TxDetail)(nil), "rpcpb.TxDetail")
	proto.RegisterType((*TxInDetail)(nil), "rpcpb.TxInDetail")
	proto.RegisterType((*TxOutDetail)(nil), "rpcpb.TxOutDetail")
	proto.RegisterType((*BlockDetail)(nil), "rpcpb.BlockDetail")
	proto.RegisterType((*TokenIssueInfo)(nil), "rpcpb.TokenIssueInfo")
	proto.RegisterType((*SplitContractInfo)(nil), "rpcpb.SplitContractInfo")
	proto.RegisterType((*TokenTransferInfo)(nil), "rpcpb.TokenTransferInfo")
	proto.RegisterType((*CallReq)(nil), "rpcpb.CallReq")
	proto.RegisterType((*CallResp)(nil), "rpcpb.CallResp")
	proto.RegisterType((*NonceReq)(nil), "rpcpb.NonceReq")
	proto.RegisterType((*NonceResp)(nil), "rpcpb.NonceResp")
	proto.RegisterType((*TableReq)(nil), "rpcpb.TableReq")
	proto.RegisterType((*TableResp)(nil), "rpcpb.TableResp")
}

func init() { proto.RegisterFile("web.proto", fileDescriptor_461bb3ac99194e85) }

var fileDescriptor_461bb3ac99194e85 = []byte{
	// 1774 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x17, 0x4d, 0x6f, 0x1c, 0x49,
	0xd5, 0x3d, 0x9f, 0xdd, 0x6f, 0x3c, 0x76, 0xbb, 0x92, 0x75, 0x26, 0x93, 0x60, 0x9c, 0x4e, 0xb4,
	0x6b, 0x99, 0x95, 0x1d, 0x8c, 0xc4, 0x21, 0x07, 0xc4, 0x3a, 0x96, 0xd6, 0x81, 0x68, 0x37, 0xea,
	0x18, 0x10, 0x5c, 0x5a, 0x35, 0x3d, 0xe5, 0x76, 0xcb, 0x33, 0xdd, 0x9d, 0xae, 0x6a, 0x7b, 0xcc,
	0x91, 0x5f, 0x80, 0xc4, 0x1f, 0xe0, 0xc0, 0x05, 0x24, 0xfe, 0x06, 0xda, 0xe3, 0x4a, 0x5c, 0xb8,
	0x20, 0xa1, 0x84, 0x33, 0x57, 0xae, 0xab, 0xf7, 0xaa, 0xba, 0xa7, 0x7b, 0x9c, 0xac, 0x94, 0x5b,
	0xbd, 0x8f, 0x7a, 0xdf, 0x1f, 0x55, 0xe0, 0x5c, 0x8b, 0xc9, 0x41, 0x96, 0xa7, 0x2a, 0x65, 0xdd,
	0x3c, 0x0b, 0xb3, 0xc9, 0x78, 0x4b, 0xe5, 0x3c, 0x91, 0x3c, 0x54, 0x71, 0x9a, 0x68, 0xca, 0xf8,
	0x61, 0x94, 0xa6, 0xd1, 0x4c, 0x1c, 0xf2, 0x2c, 0x3e, 0xe4, 0x49, 0x92, 0x2a, 0x8e, 0x44, 0xa9,
	0xa9, 0x5e, 0x02, 0x03, 0x5f, 0x44, 0xb1, 0x54, 0x22, 0xf7, 0xc5, 0x1b, 0xc6, 0xa0, 0xa3, 0x6e,
	0x32, 0x31, 0xb2, 0x76, 0xad, 0xbd, 0xa1, 0x4f, 0x67, 0xb6, 0x0d, 0xbd, 0x90, 0x27, 0xa1, 0x98,
	0x8d, 0x5a, 0xbb, 0xd6, 0x9e, 0xed, 0x1b, 0x88, 0xfd, 0x08, 0xec, 0x59, 0x1a, 0xc9, 0x20, 0x17,
	0x6f, 0x46, 0xed, 0x5d, 0x6b, 0x6f, 0x70, 0xb4, 0x71, 0x40, 0x56, 0x1c, 0xbc, 0x4c, 0x23, 0xe9,
	0x8b, 0x37, 0xa7, 0x6b, 0x7e, 0x7f, 0xa6, 0x8f, 0xc7, 0x3d, 0xe8, 0xc4, 0xc9, 0x79, 0xea, 0xfd,
	0xdd, 0x82, 0xf5, 0x97, 0xa8, 0x2e, 0x11, 0xd3, 0x13, 0xae, 0xf8, 0x7b, 0x35, 0xee, 0x43, 0x77,
	0x32, 0x4b, 0xc3, 0x4b, 0x52, 0x38, 0x38, 0x62, 0x46, 0xec, 0x31, 0xe2, 0x4e, 0x84, 0xe2, 0xf1,
	0xec, 0x74, 0xcd, 0xd7, 0x2c, 0xec, 0x33, 0xe8, 0xa0, 0x0e, 0x63, 0xc1, 0xd6, 0xd2, 0x02, 0xcd,
	0x28, 0x4f, 0xd7, 0x7c, 0x62, 0x60, 0x9f, 0x6b, 0x0b, 0x46, 0x1d, 0x62, 0xdc, 0x36, 0x8c, 0xa5,
	0xf3, 0x35, 0x6e, 0xe4, 0x42, 0x7b, 0xa7, 0x5c, 0x71, 0xef, 0x31, 0x6c, 0xae, 0xb0, 0x30, 0x17,
	0xda, 0x45, 0x3c, 0x25, 0x83, 0x1d, 0x1f, 0x8f, 0xde, 0x29, 0x6c, 0xfe, 0x3a, 0x16, 0xd7, 0x67,
	0x0b, 0xcd, 0x62, 0x02, 0x79, 0xc1, 0xe5, 0x85, 0xe1, 0xa2, 0x33, 0x7b, 0x04, 0xeb, 0x32, 0xcb,
	0x05, 0x9f, 0x06, 0x32, 0x9b, 0xc5, 0xca, 0x84, 0x73, 0xa0, 0x71, 0xaf, 0x11, 0xe5, 0xfd, 0xcf,
	0x02, 0xb7, 0x29, 0x4a, 0x66, 0x28, 0x2b, 0x4c, 0xa7, 0x3a, 0x44, 0x5d, 0x9f, 0xce, 0x6c, 0x04,
	0xfd, 0xb9, 0x90, 0x92, 0x47, 0x82, 0xc4, 0x38, 0x7e, 0x09, 0x22, 0xe5, 0x4a, 0xe4, 0x32, 0x4e,
	0x13, 0x8a, 0x49, 0xd7, 0x2f, 0x41, 0xf6, 0x03, 0x00, 0x8a, 0x59, 0xa0, 0xe2, 0xb9, 0xa0, 0x38,
	0xb4, 0x7d, 0x87, 0x30, 0x67, 0xf1, 0x5c, 0xa0, 0x79, 0x9a, 0x7c, 0x21, 0xe2, 0xe8, 0x42, 0x8d,
	0xba, 0x94, 0x91, 0x01, 0xe1, 0x4e, 0x09, 0xc5, 0x3e, 0x83, 0x9e, 0x54, 0x5c, 0x15, 0x72, 0xd4,
	0xdb, 0xb5, 0xf6, 0x36, 0x8e, 0x36, 0x4d, 0x14, 0xcf, 0x16, 0xaf, 0x09, 0xed, 0x1b, 0x32, 0x32,
	0x4e, 0xc9, 0x81, 0x51, 0x9f, 0xc2, 0xbd, 0x64, 0x34, 0x7e, 0x19, 0xb2, 0xb7, 0x07, 0x0c, 0xfd,
	0xad, 0xa5, 0xf6, 0x03, 0xd1, 0xf3, 0x52, 0xb8, 0x73, 0x8b, 0xf3, 0xa3, 0x83, 0xb3, 0x5f, 0xd9,
	0xd5, 0xfe, 0x50, 0x69, 0x55, 0xa6, 0xfd, 0xdb, 0x82, 0xf5, 0xe7, 0x69, 0xa2, 0x72, 0x1e, 0xaa,
	0x17, 0xc9, 0x79, 0x8a, 0x89, 0x3f, 0x17, 0x65, 0xa5, 0xe2, 0x11, 0x5b, 0xe3, 0x9c, 0xc7, 0x33,
	0x31, 0x2d, 0x5b, 0x43, 0x43, 0xec, 0x01, 0x38, 0x11, 0x97, 0xc1, 0x2c, 0x9e, 0xc7, 0x8a, 0x34,
	0x75, 0x7c, 0x3b, 0xe2, 0xf2, 0x25, 0xc2, 0xec, 0x3e, 0xe0, 0x39, 0x28, 0xa4, 0x98, 0x52, 0x12,
	0x3a, 0x7e, 0x3f, 0xe2, 0xf2, 0x57, 0x72, 0x79, 0x2f, 0xcb, 0xe3, 0x50, 0x50, 0xfc, 0xf5, 0xbd,
	0x57, 0x08, 0xb3, 0xbb, 0xd0, 0x4d, 0xd2, 0x24, 0x14, 0x14, 0xfb, 0x8e, 0xaf, 0x01, 0xf4, 0x1f,
	0x0b, 0x95, 0xe2, 0xec, 0xf8, 0x74, 0x66, 0x4f, 0x4c, 0x4f, 0xd8, 0xbb, 0xed, 0xbd, 0xc1, 0x91,
	0xbb, 0xda, 0x13, 0xba, 0x21, 0xbc, 0x2d, 0xd8, 0xd4, 0x9d, 0x48, 0xce, 0x63, 0x97, 0x7a, 0xdf,
	0x58, 0xd0, 0x37, 0xcd, 0x7b, 0xbb, 0xcc, 0xab, 0xac, 0xb4, 0x6a, 0x35, 0xcd, 0xa0, 0x73, 0x9e,
	0xa7, 0x73, 0x72, 0x72, 0xe8, 0xd3, 0x99, 0x6d, 0x40, 0x4b, 0xe9, 0x3e, 0x1b, 0xfa, 0x2d, 0x95,
	0xb2, 0x87, 0xe0, 0xf0, 0xe9, 0x34, 0x17, 0x52, 0x0a, 0x39, 0xea, 0xee, 0xb6, 0xf7, 0x1c, 0x7f,
	0x89, 0x60, 0x4f, 0xa1, 0xa7, 0xd2, 0x2c, 0x0e, 0xb1, 0xa6, 0xd0, 0xdc, 0x51, 0x73, 0x88, 0x1c,
	0x10, 0x71, 0x16, 0x4b, 0xe5, 0x1b, 0xbe, 0xf1, 0x63, 0x70, 0x2a, 0x24, 0xa6, 0xc0, 0x5c, 0xb7,
	0x48, 0xb2, 0x81, 0xbc, 0xdf, 0x41, 0x07, 0x25, 0x7c, 0x64, 0x7d, 0x3c, 0xa9, 0xa6, 0xc9, 0xf7,
	0x45, 0xee, 0x08, 0x60, 0x39, 0x60, 0xaa, 0x3b, 0xd6, 0xf7, 0xde, 0xf9, 0xbf, 0x05, 0x4e, 0x85,
	0x43, 0x0b, 0x4c, 0x04, 0x4c, 0x80, 0x4b, 0xb0, 0xe6, 0x4f, 0xab, 0xee, 0x4f, 0x95, 0xe7, 0x76,
	0x2d, 0xcf, 0x55, 0xc7, 0x26, 0xc5, 0x7c, 0x22, 0x72, 0x53, 0x4d, 0xba, 0x63, 0xbf, 0x22, 0x14,
	0xbb, 0x07, 0x7d, 0xb5, 0x08, 0x28, 0x6d, 0x5d, 0xba, 0xd9, 0x53, 0x8b, 0x53, 0x4c, 0xdc, 0x7d,
	0xb0, 0xd5, 0x22, 0x88, 0x93, 0xa9, 0x58, 0x50, 0x41, 0x0d, 0xfd, 0xbe, 0x5a, 0xbc, 0x40, 0x70,
	0x39, 0x27, 0xe8, 0x9a, 0x2e, 0x2c, 0x3d, 0x27, 0xe8, 0xe6, 0x5d, 0xe8, 0xea, 0x6b, 0x36, 0x5d,
	0xd3, 0x00, 0x7a, 0x94, 0x8b, 0x79, 0x7a, 0x25, 0xa6, 0x23, 0x87, 0x7a, 0xa1, 0x04, 0xbd, 0x4b,
	0xb0, 0xcb, 0xb6, 0x7f, 0xef, 0x58, 0x7c, 0x0c, 0xed, 0xab, 0x38, 0x21, 0x77, 0x97, 0x03, 0xfc,
	0x6c, 0xf1, 0x22, 0x31, 0xf1, 0x43, 0x2a, 0xfb, 0x14, 0x3a, 0x57, 0x69, 0xa1, 0x4c, 0x62, 0x58,
	0xc5, 0xf5, 0x75, 0xa1, 0xca, 0x30, 0x23, 0xdd, 0xfb, 0xab, 0x05, 0xb0, 0xbc, 0xcb, 0x9e, 0xc1,
	0x66, 0x96, 0x8b, 0xab, 0x20, 0x2d, 0x54, 0x60, 0x1a, 0xdf, 0x6a, 0x34, 0x7e, 0x5d, 0xc2, 0x10,
	0x59, 0x2b, 0x10, 0xc3, 0x20, 0xc3, 0x3c, 0xce, 0x54, 0x20, 0xe3, 0xc8, 0x14, 0x8a, 0xa3, 0x31,
	0xaf, 0xe3, 0x88, 0x8d, 0xc1, 0x96, 0xe2, 0x4d, 0x21, 0xb0, 0x23, 0x75, 0xf5, 0x57, 0x30, 0x7b,
	0x02, 0x1b, 0x95, 0xda, 0x2c, 0x8d, 0x13, 0x45, 0xa9, 0x71, 0xfc, 0x75, 0xa3, 0xe1, 0x15, 0xe2,
	0xbc, 0x3f, 0x77, 0x61, 0x50, 0xd3, 0x8f, 0xc1, 0xc1, 0x2a, 0x28, 0x83, 0x83, 0x67, 0x0c, 0xf6,
	0x15, 0x9f, 0x15, 0xba, 0x50, 0x3b, 0xbe, 0x06, 0x50, 0xbe, 0x31, 0x2d, 0x2b, 0x26, 0xc1, 0xa5,
	0xb8, 0x31, 0x65, 0xb1, 0xae, 0xb1, 0xaf, 0x8a, 0xc9, 0x2f, 0xc5, 0x0d, 0x7b, 0x0c, 0x43, 0xc3,
	0x35, 0x8d, 0x25, 0x97, 0xf3, 0xd2, 0x08, 0x8d, 0x3c, 0x21, 0x1c, 0x7b, 0x6a, 0xf6, 0x6f, 0x97,
	0x06, 0xfa, 0xc3, 0xdb, 0x61, 0xd1, 0xe7, 0xb3, 0x9b, 0x4c, 0x98, 0xed, 0xfc, 0x05, 0xb8, 0x2a,
	0xbd, 0x14, 0x49, 0x10, 0x4b, 0x59, 0x88, 0x80, 0x96, 0x6a, 0x8f, 0x82, 0xfa, 0x49, 0x79, 0x1b,
	0xc9, 0x2f, 0x90, 0x8a, 0x73, 0xf3, 0x74, 0xcd, 0xdf, 0x50, 0x0d, 0x0c, 0xfb, 0x05, 0xdc, 0xd1,
	0x22, 0xe8, 0xb9, 0x72, 0x2e, 0x72, 0x2d, 0x45, 0xef, 0x8a, 0x51, 0x5d, 0xca, 0x99, 0x61, 0x30,
	0x82, 0xb6, 0xd4, 0x2a, 0x12, 0x65, 0xd1, 0x3a, 0x0d, 0x42, 0x33, 0xab, 0xb5, 0x2c, 0xbb, 0x21,
	0x8b, 0xb6, 0x6b, 0x7d, 0x98, 0xa3, 0x2c, 0xb9, 0x8a, 0x64, 0xcf, 0x60, 0xd8, 0x94, 0xe2, 0x90,
	0x94, 0x3b, 0x46, 0xca, 0x8a, 0x80, 0xf5, 0xb0, 0x06, 0x7b, 0xff, 0xb0, 0xc0, 0xa9, 0x42, 0xc5,
	0x06, 0xd0, 0x2f, 0x92, 0xcb, 0x24, 0xbd, 0x4e, 0xdc, 0x35, 0xb6, 0x0d, 0x2c, 0xe3, 0x37, 0x81,
	0x4a, 0x31, 0x5d, 0x97, 0xe2, 0x86, 0x1a, 0xcb, 0xb5, 0xd8, 0x03, 0xb8, 0x77, 0x1b, 0x1f, 0x84,
	0x33, 0x75, 0xe5, 0xb6, 0xd8, 0x26, 0x0c, 0x6a, 0x61, 0x76, 0xdb, 0x8c, 0xc1, 0x46, 0x33, 0x68,
	0x6e, 0x07, 0x71, 0x89, 0xb8, 0xd6, 0xef, 0x89, 0x00, 0x0b, 0xc6, 0xed, 0xd6, 0xb4, 0x99, 0xec,
	0x93, 0xb6, 0x1e, 0xbb, 0x03, 0x9b, 0x95, 0x73, 0x61, 0x2e, 0xb8, 0x12, 0x6e, 0x9f, 0x6d, 0xd5,
	0x3c, 0x0e, 0xf9, 0x6c, 0xe6, 0xda, 0xc7, 0x00, 0x36, 0xcf, 0x32, 0x91, 0x4c, 0xe3, 0x85, 0xf7,
	0xb7, 0x16, 0x0c, 0x6a, 0xbb, 0xb1, 0xfe, 0xb8, 0xb0, 0x9a, 0x8f, 0x8b, 0x6d, 0xe8, 0x99, 0x77,
	0x43, 0x8b, 0x9a, 0xc1, 0x40, 0xd8, 0x45, 0xf8, 0xdc, 0x08, 0xa4, 0xe2, 0xf3, 0x8c, 0xca, 0xb4,
	0xed, 0x3b, 0x88, 0x79, 0x8d, 0x08, 0xac, 0x79, 0x19, 0xff, 0x5e, 0x98, 0x6d, 0x41, 0xe7, 0x6a,
	0x48, 0x74, 0x6b, 0x43, 0xe2, 0x53, 0xd3, 0xc8, 0xb5, 0xc1, 0xd4, 0x23, 0x32, 0x35, 0xed, 0x71,
	0x35, 0x9c, 0x1e, 0x80, 0x13, 0xa6, 0x71, 0x12, 0x4c, 0xb8, 0x14, 0x66, 0x74, 0xd9, 0x88, 0x38,
	0xe6, 0x52, 0xe0, 0x22, 0x0a, 0xd3, 0xe4, 0x3c, 0xce, 0xe7, 0x62, 0x4a, 0x05, 0x62, 0xfb, 0x4b,
	0x04, 0x52, 0x65, 0x1c, 0x25, 0x5c, 0x15, 0xb9, 0xa0, 0xc4, 0x63, 0xbb, 0x97, 0x08, 0xf6, 0x08,
	0xda, 0x6a, 0x21, 0x47, 0x40, 0xf3, 0xe7, 0xd6, 0x73, 0x06, 0x69, 0xde, 0xcf, 0x60, 0xa3, 0x59,
	0xf9, 0xec, 0x73, 0xdc, 0x54, 0x94, 0x32, 0x1e, 0x99, 0xc1, 0xb3, 0xd9, 0xa8, 0x6e, 0x1e, 0xf9,
	0xb6, 0x32, 0x27, 0xef, 0x39, 0x6c, 0xdd, 0xaa, 0x53, 0x1c, 0x00, 0x98, 0xd7, 0x72, 0xbd, 0x69,
	0x00, 0xf3, 0x70, 0x4d, 0xf1, 0xd5, 0x6b, 0x62, 0xe8, 0x97, 0xa0, 0x77, 0x00, 0x5b, 0xb7, 0x1a,
	0x87, 0x86, 0xbd, 0xae, 0xa5, 0x72, 0xa1, 0xf7, 0x75, 0x47, 0x4e, 0x3d, 0x09, 0xfd, 0xe7, 0x7c,
	0x56, 0xbe, 0xba, 0x68, 0x97, 0x9b, 0xf9, 0x53, 0xdb, 0xe5, 0x7a, 0xf8, 0xe1, 0x2e, 0x7f, 0xdf,
	0x1a, 0x5a, 0xa6, 0xbe, 0xd3, 0x48, 0xfd, 0x08, 0xfa, 0x98, 0x68, 0x1c, 0xdb, 0x5d, 0xb3, 0x61,
	0x34, 0xe8, 0xbd, 0x02, 0x5b, 0x2b, 0xfd, 0xe8, 0x07, 0xdc, 0x36, 0xf4, 0xd2, 0x42, 0x65, 0x85,
	0x32, 0x16, 0x18, 0xc8, 0xdb, 0x01, 0xfb, 0x2b, 0x7c, 0x0f, 0x19, 0x3f, 0x56, 0xe7, 0xa8, 0xf7,
	0x35, 0x38, 0x86, 0xfe, 0xd1, 0x2a, 0xab, 0x77, 0x57, 0xbb, 0xf6, 0xee, 0xf2, 0x00, 0xec, 0x33,
	0x3e, 0x99, 0xa1, 0x42, 0xef, 0x11, 0x38, 0xe6, 0x2c, 0x33, 0x64, 0x57, 0x08, 0x94, 0x09, 0x23,
	0x60, 0xff, 0xe7, 0xb8, 0x04, 0xf5, 0x23, 0xb9, 0x39, 0x1b, 0x06, 0xd0, 0xa7, 0x5e, 0x4b, 0x22,
	0xd7, 0x42, 0x20, 0x4d, 0xc2, 0x0b, 0x1e, 0x27, 0x6e, 0x8b, 0x0d, 0x6b, 0xd5, 0xea, 0xb6, 0x8f,
	0xfe, 0xd2, 0x81, 0xde, 0x6f, 0xc4, 0xe4, 0x8b, 0x2c, 0x66, 0xbf, 0x85, 0xf5, 0xfa, 0x27, 0x81,
	0x95, 0x9f, 0x99, 0x95, 0x4f, 0xc8, 0xf8, 0xde, 0x7b, 0xf1, 0x32, 0xf3, 0x46, 0x7f, 0xf8, 0xe7,
	0x7f, 0xff, 0xd4, 0x62, 0xde, 0xf0, 0xf0, 0xea, 0xc7, 0x87, 0x6a, 0x71, 0xa8, 0x57, 0xe3, 0x33,
	0x6b, 0x9f, 0x09, 0xfd, 0x95, 0xa9, 0xf7, 0xfc, 0xfd, 0x9a, 0x94, 0xe6, 0x3b, 0x7d, 0x3c, 0xfe,
	0x10, 0x49, 0x66, 0xde, 0x03, 0xd2, 0xf1, 0x89, 0xe7, 0xa2, 0x0e, 0x6a, 0xdb, 0x9a, 0x9a, 0x2f,
	0xa1, 0x77, 0x92, 0x62, 0x09, 0xb0, 0xf2, 0xcf, 0x68, 0x8a, 0x70, 0xbc, 0xd9, 0x80, 0x65, 0xe6,
	0x3d, 0x24, 0x39, 0xdb, 0xde, 0x16, 0xca, 0x29, 0x67, 0xd5, 0x21, 0xce, 0x2a, 0x14, 0x74, 0x0a,
	0x5d, 0xca, 0x2b, 0x2b, 0xef, 0x95, 0x55, 0x30, 0x76, 0x9b, 0x88, 0x55, 0x49, 0x3c, 0x0c, 0xd3,
	0x22, 0x51, 0x87, 0x94, 0x4d, 0x6d, 0x52, 0xff, 0x4b, 0xa1, 0xe8, 0xcd, 0xb8, 0xf2, 0x8f, 0x1d,
	0x0f, 0x6a, 0xb0, 0xf7, 0x43, 0x92, 0x72, 0xdf, 0xbb, 0xdb, 0xb0, 0x27, 0xd2, 0x57, 0x51, 0xd0,
	0x4f, 0xa1, 0xff, 0x3c, 0x4d, 0x12, 0x11, 0x2a, 0xc6, 0x56, 0x7e, 0x99, 0x28, 0xac, 0x5c, 0x26,
	0xf5, 0x5f, 0xf0, 0x9e, 0xf5, 0xd4, 0x62, 0x27, 0xd0, 0xa5, 0x2a, 0xaa, 0x5c, 0x29, 0xeb, 0xab,
	0x72, 0xa5, 0x2a, 0xb2, 0x66, 0x02, 0xb3, 0xa3, 0xec, 0x90, 0xaa, 0xec, 0x99, 0xb5, 0x7f, 0x3c,
	0xfa, 0xe6, 0xed, 0x8e, 0xf5, 0xed, 0xdb, 0x1d, 0xeb, 0x3f, 0x6f, 0x77, 0xac, 0x3f, 0xbe, 0xdb,
	0x59, 0xfb, 0xf6, 0xdd, 0xce, 0xda, 0xbf, 0xde, 0xed, 0xac, 0x4d, 0x7a, 0xf4, 0xe3, 0xff, 0xc9,
	0x77, 0x01, 0x00, 0x00, 0xff, 0xff, 0x5b, 0x5a, 0xc0, 0x29, 0x36, 0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WebApiClient is the client API for WebApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WebApiClient interface {
	ViewTxDetail(ctx context.Context, in *ViewTxDetailReq, opts ...grpc.CallOption) (*ViewTxDetailResp, error)
	ViewBlockDetail(ctx context.Context, in *ViewBlockDetailReq, opts ...grpc.CallOption) (*ViewBlockDetailResp, error)
	DoCall(ctx context.Context, in *CallReq, opts ...grpc.CallOption) (*CallResp, error)
	Nonce(ctx context.Context, in *NonceReq, opts ...grpc.CallOption) (*NonceResp, error)
	GetLogs(ctx context.Context, in *LogsReq, opts ...grpc.CallOption) (*Logs, error)
	Connect(ctx context.Context, opts ...grpc.CallOption) (WebApi_ConnectClient, error)
	Table(ctx context.Context, in *TableReq, opts ...grpc.CallOption) (*TableResp, error)
}

type webApiClient struct {
	cc *grpc.ClientConn
}

func NewWebApiClient(cc *grpc.ClientConn) WebApiClient {
	return &webApiClient{cc}
}

func (c *webApiClient) ViewTxDetail(ctx context.Context, in *ViewTxDetailReq, opts ...grpc.CallOption) (*ViewTxDetailResp, error) {
	out := new(ViewTxDetailResp)
	err := c.cc.Invoke(ctx, "/rpcpb.WebApi/ViewTxDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webApiClient) ViewBlockDetail(ctx context.Context, in *ViewBlockDetailReq, opts ...grpc.CallOption) (*ViewBlockDetailResp, error) {
	out := new(ViewBlockDetailResp)
	err := c.cc.Invoke(ctx, "/rpcpb.WebApi/ViewBlockDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webApiClient) DoCall(ctx context.Context, in *CallReq, opts ...grpc.CallOption) (*CallResp, error) {
	out := new(CallResp)
	err := c.cc.Invoke(ctx, "/rpcpb.WebApi/DoCall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webApiClient) Nonce(ctx context.Context, in *NonceReq, opts ...grpc.CallOption) (*NonceResp, error) {
	out := new(NonceResp)
	err := c.cc.Invoke(ctx, "/rpcpb.WebApi/Nonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webApiClient) GetLogs(ctx context.Context, in *LogsReq, opts ...grpc.CallOption) (*Logs, error) {
	out := new(Logs)
	err := c.cc.Invoke(ctx, "/rpcpb.WebApi/GetLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webApiClient) Connect(ctx context.Context, opts ...grpc.CallOption) (WebApi_ConnectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_WebApi_serviceDesc.Streams[0], "/rpcpb.WebApi/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &webApiConnectClient{stream}
	return x, nil
}

type WebApi_ConnectClient interface {
	Send(*RegisterReq) error
	Recv() (*ListenedData, error)
	grpc.ClientStream
}

type webApiConnectClient struct {
	grpc.ClientStream
}

func (x *webApiConnectClient) Send(m *RegisterReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *webApiConnectClient) Recv() (*ListenedData, error) {
	m := new(ListenedData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *webApiClient) Table(ctx context.Context, in *TableReq, opts ...grpc.CallOption) (*TableResp, error) {
	out := new(TableResp)
	err := c.cc.Invoke(ctx, "/rpcpb.WebApi/Table", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebApiServer is the server API for WebApi service.
type WebApiServer interface {
	ViewTxDetail(context.Context, *ViewTxDetailReq) (*ViewTxDetailResp, error)
	ViewBlockDetail(context.Context, *ViewBlockDetailReq) (*ViewBlockDetailResp, error)
	DoCall(context.Context, *CallReq) (*CallResp, error)
	Nonce(context.Context, *NonceReq) (*NonceResp, error)
	GetLogs(context.Context, *LogsReq) (*Logs, error)
	Connect(WebApi_ConnectServer) error
	Table(context.Context, *TableReq) (*TableResp, error)
}

// UnimplementedWebApiServer can be embedded to have forward compatible implementations.
type UnimplementedWebApiServer struct {
}

func (*UnimplementedWebApiServer) ViewTxDetail(ctx context.Context, req *ViewTxDetailReq) (*ViewTxDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewTxDetail not implemented")
}
func (*UnimplementedWebApiServer) ViewBlockDetail(ctx context.Context, req *ViewBlockDetailReq) (*ViewBlockDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewBlockDetail not implemented")
}
func (*UnimplementedWebApiServer) DoCall(ctx context.Context, req *CallReq) (*CallResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoCall not implemented")
}
func (*UnimplementedWebApiServer) Nonce(ctx context.Context, req *NonceReq) (*NonceResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Nonce not implemented")
}
func (*UnimplementedWebApiServer) GetLogs(ctx context.Context, req *LogsReq) (*Logs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogs not implemented")
}
func (*UnimplementedWebApiServer) Connect(srv WebApi_ConnectServer) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (*UnimplementedWebApiServer) Table(ctx context.Context, req *TableReq) (*TableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Table not implemented")
}

func RegisterWebApiServer(s *grpc.Server, srv WebApiServer) {
	s.RegisterService(&_WebApi_serviceDesc, srv)
}

func _WebApi_ViewTxDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewTxDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebApiServer).ViewTxDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.WebApi/ViewTxDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebApiServer).ViewTxDetail(ctx, req.(*ViewTxDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebApi_ViewBlockDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewBlockDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebApiServer).ViewBlockDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.WebApi/ViewBlockDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebApiServer).ViewBlockDetail(ctx, req.(*ViewBlockDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebApi_DoCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebApiServer).DoCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.WebApi/DoCall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebApiServer).DoCall(ctx, req.(*CallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebApi_Nonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NonceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebApiServer).Nonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.WebApi/Nonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebApiServer).Nonce(ctx, req.(*NonceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebApi_GetLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebApiServer).GetLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.WebApi/GetLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebApiServer).GetLogs(ctx, req.(*LogsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebApi_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WebApiServer).Connect(&webApiConnectServer{stream})
}

type WebApi_ConnectServer interface {
	Send(*ListenedData) error
	Recv() (*RegisterReq, error)
	grpc.ServerStream
}

type webApiConnectServer struct {
	grpc.ServerStream
}

func (x *webApiConnectServer) Send(m *ListenedData) error {
	return x.ServerStream.SendMsg(m)
}

func (x *webApiConnectServer) Recv() (*RegisterReq, error) {
	m := new(RegisterReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _WebApi_Table_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebApiServer).Table(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.WebApi/Table",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebApiServer).Table(ctx, req.(*TableReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _WebApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpcpb.WebApi",
	HandlerType: (*WebApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ViewTxDetail",
			Handler:    _WebApi_ViewTxDetail_Handler,
		},
		{
			MethodName: "ViewBlockDetail",
			Handler:    _WebApi_ViewBlockDetail_Handler,
		},
		{
			MethodName: "DoCall",
			Handler:    _WebApi_DoCall_Handler,
		},
		{
			MethodName: "Nonce",
			Handler:    _WebApi_Nonce_Handler,
		},
		{
			MethodName: "GetLogs",
			Handler:    _WebApi_GetLogs_Handler,
		},
		{
			MethodName: "Table",
			Handler:    _WebApi_Table_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _WebApi_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "web.proto",
}

func (m *RegisterReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size := m.Info.Size()
			i -= size
			if _, err := m.Info.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Cancel {
		i--
		if m.Cancel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterReq_LogsReq) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RegisterReq_LogsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogsReq != nil {
		{
			size, err := m.LogsReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ListenedData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListenedData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListenedData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListenedData_Block) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ListenedData_Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ListenedData_Logs) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ListenedData_Logs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Logs != nil {
		{
			size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ListenedData_Info) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ListenedData_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RegisterDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewTxDetailReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewTxDetailReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewTxDetailReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpreadSplit {
		i--
		if m.SpreadSplit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewTxDetailResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewTxDetailResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewTxDetailResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Detail != nil {
		{
			size, err := m.Detail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.BlockHeight != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.BlockTime != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ViewBlockDetailReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewBlockDetailReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewBlockDetailReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewBlockDetailResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewBlockDetailResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewBlockDetailResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Detail != nil {
		{
			size, err := m.Detail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContractInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Logs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWeb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Nonce != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x30
	}
	if m.GasPrice != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.GasPrice))
		i--
		dAtA[i] = 0x28
	}
	if m.GasUsed != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x20
	}
	if m.GasLimit != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.GasLimit))
		i--
		dAtA[i] = 0x18
	}
	if m.Failed {
		i--
		if m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Fee != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Fee))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListenBlocksReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListenBlocksReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListenBlocksReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LogsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Topics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWeb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintWeb(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.To != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x20
	}
	if m.From != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogsReqTopiclist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogsReqTopiclist) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogsReqTopiclist) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Topics[iNdEx])
			copy(dAtA[i:], m.Topics[iNdEx])
			i = encodeVarintWeb(dAtA, i, uint64(len(m.Topics[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Logs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Logs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Logs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Logs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWeb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Logs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWeb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LogDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Removed {
		i--
		if m.Removed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Index != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x40
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TxIndex != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.TxIndex))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BlockNumber != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Topics[iNdEx])
			copy(dAtA[i:], m.Topics[iNdEx])
			i = encodeVarintWeb(dAtA, i, uint64(len(m.Topics[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vout) > 0 {
		for iNdEx := len(m.Vout) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vout[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWeb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Vin) > 0 {
		for iNdEx := len(m.Vin) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vin[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWeb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxInDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxInDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxInDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrevOutPoint) > 0 {
		i -= len(m.PrevOutPoint)
		copy(dAtA[i:], m.PrevOutPoint)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.PrevOutPoint)))
		i--
		dAtA[i] = 0x22
	}
	if m.Sequence != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ScriptSig) > 0 {
		i -= len(m.ScriptSig)
		copy(dAtA[i:], m.ScriptSig)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.ScriptSig)))
		i--
		dAtA[i] = 0x12
	}
	if m.PrevOutDetail != nil {
		{
			size, err := m.PrevOutDetail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxOutDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxOutDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxOutDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Appendix != nil {
		{
			size := m.Appendix.Size()
			i -= size
			if _, err := m.Appendix.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ScriptDisasm) > 0 {
		i -= len(m.ScriptDisasm)
		copy(dAtA[i:], m.ScriptDisasm)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.ScriptDisasm)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ScriptPubKey) > 0 {
		i -= len(m.ScriptPubKey)
		copy(dAtA[i:], m.ScriptPubKey)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.ScriptPubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Value != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxOutDetail_TokenIssueInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *TxOutDetail_TokenIssueInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TokenIssueInfo != nil {
		{
			size, err := m.TokenIssueInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *TxOutDetail_TokenTransferInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *TxOutDetail_TokenTransferInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TokenTransferInfo != nil {
		{
			size, err := m.TokenTransferInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TxOutDetail_SplitContractInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *TxOutDetail_SplitContractInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SplitContractInfo != nil {
		{
			size, err := m.SplitContractInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *TxOutDetail_ContractInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *TxOutDetail_ContractInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ContractInfo != nil {
		{
			size, err := m.ContractInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *BlockDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Txs) > 0 {
		for iNdEx := len(m.Txs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Txs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWeb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Confirmed {
		i--
		if m.Confirmed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.CoinBase) > 0 {
		i -= len(m.CoinBase)
		copy(dAtA[i:], m.CoinBase)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.CoinBase)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PrevBlockHash) > 0 {
		i -= len(m.PrevBlockHash)
		copy(dAtA[i:], m.PrevBlockHash)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.PrevBlockHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Size_ != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeStamp != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.TimeStamp))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TokenIssueInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenIssueInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenIssueInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TokenTag != nil {
		{
			size, err := m.TokenTag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitContractInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitContractInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitContractInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Weights) > 0 {
		dAtA14 := make([]byte, len(m.Weights)*10)
		var j13 int
		for _, num := range m.Weights {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintWeb(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addrs) > 0 {
		for iNdEx := len(m.Addrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addrs[iNdEx])
			copy(dAtA[i:], m.Addrs[iNdEx])
			i = encodeVarintWeb(dAtA, i, uint64(len(m.Addrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TokenTransferInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenTransferInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenTransferInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenId) > 0 {
		i -= len(m.TokenId)
		copy(dAtA[i:], m.TokenId)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.TokenId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CallReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x28
	}
	if m.Height != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CallResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Output) > 0 {
		i -= len(m.Output)
		copy(dAtA[i:], m.Output)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Output)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NonceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NonceReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NonceReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NonceResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NonceResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NonceResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintWeb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TableResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Table) > 0 {
		for iNdEx := len(m.Table) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Table[iNdEx])
			copy(dAtA[i:], m.Table[iNdEx])
			i = encodeVarintWeb(dAtA, i, uint64(len(m.Table[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintWeb(dAtA []byte, offset int, v uint64) int {
	offset -= sovWeb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RegisterReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovWeb(uint64(m.Type))
	}
	if m.Cancel {
		n += 2
	}
	if m.Info != nil {
		n += m.Info.Size()
	}
	return n
}

func (m *RegisterReq_LogsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogsReq != nil {
		l = m.LogsReq.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *ListenedData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovWeb(uint64(m.Type))
	}
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *ListenedData_Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *ListenedData_Logs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Logs != nil {
		l = m.Logs.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *ListenedData_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *RegisterDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *ViewTxDetailReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.SpreadSplit {
		n += 2
	}
	return n
}

func (m *ViewTxDetailResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovWeb(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovWeb(uint64(m.Version))
	}
	if m.BlockTime != 0 {
		n += 1 + sovWeb(uint64(m.BlockTime))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovWeb(uint64(m.BlockHeight))
	}
	if m.Status != 0 {
		n += 1 + sovWeb(uint64(m.Status))
	}
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *ViewBlockDetailReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *ViewBlockDetailResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovWeb(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *ContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fee != 0 {
		n += 1 + sovWeb(uint64(m.Fee))
	}
	if m.Failed {
		n += 2
	}
	if m.GasLimit != 0 {
		n += 1 + sovWeb(uint64(m.GasLimit))
	}
	if m.GasUsed != 0 {
		n += 1 + sovWeb(uint64(m.GasUsed))
	}
	if m.GasPrice != 0 {
		n += 1 + sovWeb(uint64(m.GasPrice))
	}
	if m.Nonce != 0 {
		n += 1 + sovWeb(uint64(m.Nonce))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func (m *ListenBlocksReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LogsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovWeb(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovWeb(uint64(m.To))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	if len(m.Topics) > 0 {
		for _, e := range m.Topics {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func (m *LogsReqTopiclist) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for _, s := range m.Topics {
			l = len(s)
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func (m *Logs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovWeb(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func (m *LogDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func (m *LogDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Topics) > 0 {
		for _, s := range m.Topics {
			l = len(s)
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovWeb(uint64(m.BlockNumber))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.TxIndex != 0 {
		n += 1 + sovWeb(uint64(m.TxIndex))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovWeb(uint64(m.Index))
	}
	if m.Removed {
		n += 2
	}
	return n
}

func (m *TxDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Vin) > 0 {
		for _, e := range m.Vin {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	if len(m.Vout) > 0 {
		for _, e := range m.Vout {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func (m *TxInDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevOutDetail != nil {
		l = m.PrevOutDetail.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.ScriptSig)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovWeb(uint64(m.Sequence))
	}
	l = len(m.PrevOutPoint)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *TxOutDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovWeb(uint64(m.Value))
	}
	l = len(m.ScriptPubKey)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.ScriptDisasm)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovWeb(uint64(m.Type))
	}
	if m.Appendix != nil {
		n += m.Appendix.Size()
	}
	return n
}

func (m *TxOutDetail_TokenIssueInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenIssueInfo != nil {
		l = m.TokenIssueInfo.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *TxOutDetail_TokenTransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenTransferInfo != nil {
		l = m.TokenTransferInfo.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *TxOutDetail_SplitContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SplitContractInfo != nil {
		l = m.SplitContractInfo.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *TxOutDetail_ContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContractInfo != nil {
		l = m.ContractInfo.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *BlockDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovWeb(uint64(m.Version))
	}
	if m.Height != 0 {
		n += 1 + sovWeb(uint64(m.Height))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovWeb(uint64(m.TimeStamp))
	}
	if m.Size_ != 0 {
		n += 1 + sovWeb(uint64(m.Size_))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.PrevBlockHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.CoinBase)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Confirmed {
		n += 2
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Txs) > 0 {
		for _, e := range m.Txs {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func (m *TokenIssueInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenTag != nil {
		l = m.TokenTag.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *SplitContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			l = len(s)
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	if len(m.Weights) > 0 {
		l = 0
		for _, e := range m.Weights {
			l += sovWeb(uint64(e))
		}
		n += 1 + sovWeb(uint64(l)) + l
	}
	return n
}

func (m *TokenTransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenId)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *CallReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovWeb(uint64(m.Height))
	}
	if m.Timeout != 0 {
		n += 1 + sovWeb(uint64(m.Timeout))
	}
	return n
}

func (m *CallResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovWeb(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *NonceReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *NonceResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovWeb(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovWeb(uint64(m.Nonce))
	}
	return n
}

func (m *TableReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TableResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Table) > 0 {
		for _, s := range m.Table {
			l = len(s)
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func sovWeb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWeb(x uint64) (n int) {
	return sovWeb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RegisterReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cancel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cancel = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogsReq{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Info = &RegisterReq_LogsReq{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListenedData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListenedData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListenedData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockDetail{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ListenedData_Block{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ListenedData_Logs{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RegisterDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ListenedData_Info{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewTxDetailReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewTxDetailReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewTxDetailReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpreadSplit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SpreadSplit = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewTxDetailResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewTxDetailResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewTxDetailResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &TxDetail{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewBlockDetailReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewBlockDetailReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewBlockDetailReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewBlockDetailResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewBlockDetailResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewBlockDetailResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &BlockDetail{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			m.Fee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			m.GasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			m.GasPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasPrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, &LogDetail{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListenBlocksReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListenBlocksReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListenBlocksReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, &LogsReqTopiclist{})
			if err := m.Topics[len(m.Topics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogsReqTopiclist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: topiclist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: topiclist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Logs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Logs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Logs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, &LogDetail{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, &LogDetail{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIndex", wireType)
			}
			m.TxIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Removed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vin = append(m.Vin, &TxInDetail{})
			if err := m.Vin[len(m.Vin)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vout = append(m.Vout, &TxOutDetail{})
			if err := m.Vout[len(m.Vout)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxInDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxInDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxInDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevOutDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevOutDetail == nil {
				m.PrevOutDetail = &TxOutDetail{}
			}
			if err := m.PrevOutDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptSig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptSig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevOutPoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevOutPoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxOutDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxOutDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxOutDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptDisasm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptDisasm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TxOutDetail_TxOutType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIssueInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TokenIssueInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Appendix = &TxOutDetail_TokenIssueInfo{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenTransferInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TokenTransferInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Appendix = &TxOutDetail_TokenTransferInfo{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitContractInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SplitContractInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Appendix = &TxOutDetail_SplitContractInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContractInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Appendix = &TxOutDetail_ContractInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevBlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevBlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirmed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Confirmed = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, &TxDetail{})
			if err := m.Txs[len(m.Txs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenIssueInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenIssueInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenIssueInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenTag == nil {
				m.TokenTag = &TokenTag{}
			}
			if err := m.TokenTag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitContractInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitContractInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitContractInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Weights = append(m.Weights, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWeb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthWeb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Weights) == 0 {
					m.Weights = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Weights = append(m.Weights, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenTransferInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenTransferInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenTransferInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NonceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NonceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NonceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NonceResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NonceResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NonceResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = append(m.Table, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWeb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWeb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthWeb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWeb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthWeb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWeb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWeb   = fmt.Errorf("proto: integer overflow")
)
