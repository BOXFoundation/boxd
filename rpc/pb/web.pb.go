// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: web.proto

package rpcpb

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ViewTxDetailResp_TxStatus int32

const (
	ViewTxDetailResp_unknown   ViewTxDetailResp_TxStatus = 0
	ViewTxDetailResp_pending   ViewTxDetailResp_TxStatus = 1
	ViewTxDetailResp_onchain   ViewTxDetailResp_TxStatus = 2
	ViewTxDetailResp_confirmed ViewTxDetailResp_TxStatus = 3
)

var ViewTxDetailResp_TxStatus_name = map[int32]string{
	0: "unknown",
	1: "pending",
	2: "onchain",
	3: "confirmed",
}

var ViewTxDetailResp_TxStatus_value = map[string]int32{
	"unknown":   0,
	"pending":   1,
	"onchain":   2,
	"confirmed": 3,
}

func (x ViewTxDetailResp_TxStatus) String() string {
	return proto.EnumName(ViewTxDetailResp_TxStatus_name, int32(x))
}

func (ViewTxDetailResp_TxStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{1, 0}
}

type TxOutDetail_TxOutType int32

const (
	TxOutDetail_unknown                 TxOutDetail_TxOutType = 0
	TxOutDetail_pay_to_pubkey_hash      TxOutDetail_TxOutType = 1
	TxOutDetail_pay_to_pubkey_hash_cltv TxOutDetail_TxOutType = 2
	TxOutDetail_token_issue             TxOutDetail_TxOutType = 3
	TxOutDetail_token_transfer          TxOutDetail_TxOutType = 4
	TxOutDetail_new_split_addr          TxOutDetail_TxOutType = 5
	TxOutDetail_pay_to_script_hash      TxOutDetail_TxOutType = 6
)

var TxOutDetail_TxOutType_name = map[int32]string{
	0: "unknown",
	1: "pay_to_pubkey_hash",
	2: "pay_to_pubkey_hash_cltv",
	3: "token_issue",
	4: "token_transfer",
	5: "new_split_addr",
	6: "pay_to_script_hash",
}

var TxOutDetail_TxOutType_value = map[string]int32{
	"unknown":                 0,
	"pay_to_pubkey_hash":      1,
	"pay_to_pubkey_hash_cltv": 2,
	"token_issue":             3,
	"token_transfer":          4,
	"new_split_addr":          5,
	"pay_to_script_hash":      6,
}

func (x TxOutDetail_TxOutType) String() string {
	return proto.EnumName(TxOutDetail_TxOutType_name, int32(x))
}

func (TxOutDetail_TxOutType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{7, 0}
}

type ViewTxDetailReq struct {
	Hash        string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	SpreadSplit bool   `protobuf:"varint,2,opt,name=spread_split,json=spreadSplit,proto3" json:"spread_split,omitempty"`
}

func (m *ViewTxDetailReq) Reset()         { *m = ViewTxDetailReq{} }
func (m *ViewTxDetailReq) String() string { return proto.CompactTextString(m) }
func (*ViewTxDetailReq) ProtoMessage()    {}
func (*ViewTxDetailReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{0}
}
func (m *ViewTxDetailReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewTxDetailReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewTxDetailReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewTxDetailReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewTxDetailReq.Merge(m, src)
}
func (m *ViewTxDetailReq) XXX_Size() int {
	return m.Size()
}
func (m *ViewTxDetailReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewTxDetailReq.DiscardUnknown(m)
}

var xxx_messageInfo_ViewTxDetailReq proto.InternalMessageInfo

func (m *ViewTxDetailReq) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ViewTxDetailReq) GetSpreadSplit() bool {
	if m != nil {
		return m.SpreadSplit
	}
	return false
}

type ViewTxDetailResp struct {
	Code        int32                     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message     string                    `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Version     int32                     `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	BlockTime   int64                     `protobuf:"varint,4,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
	BlockHeight uint32                    `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	Status      ViewTxDetailResp_TxStatus `protobuf:"varint,6,opt,name=status,proto3,enum=rpcpb.ViewTxDetailResp_TxStatus" json:"status,omitempty"`
	Detail      *TxDetail                 `protobuf:"bytes,7,opt,name=detail,proto3" json:"detail,omitempty"`
}

func (m *ViewTxDetailResp) Reset()         { *m = ViewTxDetailResp{} }
func (m *ViewTxDetailResp) String() string { return proto.CompactTextString(m) }
func (*ViewTxDetailResp) ProtoMessage()    {}
func (*ViewTxDetailResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{1}
}
func (m *ViewTxDetailResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewTxDetailResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewTxDetailResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewTxDetailResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewTxDetailResp.Merge(m, src)
}
func (m *ViewTxDetailResp) XXX_Size() int {
	return m.Size()
}
func (m *ViewTxDetailResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewTxDetailResp.DiscardUnknown(m)
}

var xxx_messageInfo_ViewTxDetailResp proto.InternalMessageInfo

func (m *ViewTxDetailResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ViewTxDetailResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ViewTxDetailResp) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ViewTxDetailResp) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *ViewTxDetailResp) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ViewTxDetailResp) GetStatus() ViewTxDetailResp_TxStatus {
	if m != nil {
		return m.Status
	}
	return ViewTxDetailResp_unknown
}

func (m *ViewTxDetailResp) GetDetail() *TxDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

type ViewBlockDetailReq struct {
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *ViewBlockDetailReq) Reset()         { *m = ViewBlockDetailReq{} }
func (m *ViewBlockDetailReq) String() string { return proto.CompactTextString(m) }
func (*ViewBlockDetailReq) ProtoMessage()    {}
func (*ViewBlockDetailReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{2}
}
func (m *ViewBlockDetailReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewBlockDetailReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewBlockDetailReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewBlockDetailReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewBlockDetailReq.Merge(m, src)
}
func (m *ViewBlockDetailReq) XXX_Size() int {
	return m.Size()
}
func (m *ViewBlockDetailReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewBlockDetailReq.DiscardUnknown(m)
}

var xxx_messageInfo_ViewBlockDetailReq proto.InternalMessageInfo

func (m *ViewBlockDetailReq) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type ViewBlockDetailResp struct {
	Code    int32        `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Detail  *BlockDetail `protobuf:"bytes,3,opt,name=detail,proto3" json:"detail,omitempty"`
}

func (m *ViewBlockDetailResp) Reset()         { *m = ViewBlockDetailResp{} }
func (m *ViewBlockDetailResp) String() string { return proto.CompactTextString(m) }
func (*ViewBlockDetailResp) ProtoMessage()    {}
func (*ViewBlockDetailResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{3}
}
func (m *ViewBlockDetailResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewBlockDetailResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewBlockDetailResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewBlockDetailResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewBlockDetailResp.Merge(m, src)
}
func (m *ViewBlockDetailResp) XXX_Size() int {
	return m.Size()
}
func (m *ViewBlockDetailResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewBlockDetailResp.DiscardUnknown(m)
}

var xxx_messageInfo_ViewBlockDetailResp proto.InternalMessageInfo

func (m *ViewBlockDetailResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ViewBlockDetailResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ViewBlockDetailResp) GetDetail() *BlockDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

type ListenBlocksReq struct {
}

func (m *ListenBlocksReq) Reset()         { *m = ListenBlocksReq{} }
func (m *ListenBlocksReq) String() string { return proto.CompactTextString(m) }
func (*ListenBlocksReq) ProtoMessage()    {}
func (*ListenBlocksReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{4}
}
func (m *ListenBlocksReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListenBlocksReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListenBlocksReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListenBlocksReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListenBlocksReq.Merge(m, src)
}
func (m *ListenBlocksReq) XXX_Size() int {
	return m.Size()
}
func (m *ListenBlocksReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListenBlocksReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListenBlocksReq proto.InternalMessageInfo

type TxDetail struct {
	Hash string         `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Vin  []*TxInDetail  `protobuf:"bytes,2,rep,name=vin,proto3" json:"vin,omitempty"`
	Vout []*TxOutDetail `protobuf:"bytes,3,rep,name=vout,proto3" json:"vout,omitempty"`
}

func (m *TxDetail) Reset()         { *m = TxDetail{} }
func (m *TxDetail) String() string { return proto.CompactTextString(m) }
func (*TxDetail) ProtoMessage()    {}
func (*TxDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{5}
}
func (m *TxDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxDetail.Merge(m, src)
}
func (m *TxDetail) XXX_Size() int {
	return m.Size()
}
func (m *TxDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TxDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TxDetail proto.InternalMessageInfo

func (m *TxDetail) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *TxDetail) GetVin() []*TxInDetail {
	if m != nil {
		return m.Vin
	}
	return nil
}

func (m *TxDetail) GetVout() []*TxOutDetail {
	if m != nil {
		return m.Vout
	}
	return nil
}

type TxInDetail struct {
	PrevOutDetail *TxOutDetail `protobuf:"bytes,1,opt,name=prev_out_detail,json=prevOutDetail,proto3" json:"prev_out_detail,omitempty"`
	ScriptSig     string       `protobuf:"bytes,2,opt,name=script_sig,json=scriptSig,proto3" json:"script_sig,omitempty"`
	Sequence      uint32       `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	PrevOutPoint  string       `protobuf:"bytes,4,opt,name=prev_out_point,json=prevOutPoint,proto3" json:"prev_out_point,omitempty"`
}

func (m *TxInDetail) Reset()         { *m = TxInDetail{} }
func (m *TxInDetail) String() string { return proto.CompactTextString(m) }
func (*TxInDetail) ProtoMessage()    {}
func (*TxInDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{6}
}
func (m *TxInDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxInDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxInDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxInDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxInDetail.Merge(m, src)
}
func (m *TxInDetail) XXX_Size() int {
	return m.Size()
}
func (m *TxInDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TxInDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TxInDetail proto.InternalMessageInfo

func (m *TxInDetail) GetPrevOutDetail() *TxOutDetail {
	if m != nil {
		return m.PrevOutDetail
	}
	return nil
}

func (m *TxInDetail) GetScriptSig() string {
	if m != nil {
		return m.ScriptSig
	}
	return ""
}

func (m *TxInDetail) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *TxInDetail) GetPrevOutPoint() string {
	if m != nil {
		return m.PrevOutPoint
	}
	return ""
}

type TxOutDetail struct {
	Addr         string                `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Value        uint64                `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	ScriptPubKey string                `protobuf:"bytes,3,opt,name=script_pub_key,json=scriptPubKey,proto3" json:"script_pub_key,omitempty"`
	ScriptDisasm string                `protobuf:"bytes,4,opt,name=script_disasm,json=scriptDisasm,proto3" json:"script_disasm,omitempty"`
	Type         TxOutDetail_TxOutType `protobuf:"varint,5,opt,name=type,proto3,enum=rpcpb.TxOutDetail_TxOutType" json:"type,omitempty"`
	// Types that are valid to be assigned to Appendix:
	//	*TxOutDetail_TokenIssueInfo
	//	*TxOutDetail_TokenTransferInfo
	//	*TxOutDetail_SplitContractInfo
	Appendix isTxOutDetail_Appendix `protobuf_oneof:"appendix"`
}

func (m *TxOutDetail) Reset()         { *m = TxOutDetail{} }
func (m *TxOutDetail) String() string { return proto.CompactTextString(m) }
func (*TxOutDetail) ProtoMessage()    {}
func (*TxOutDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{7}
}
func (m *TxOutDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxOutDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxOutDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxOutDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxOutDetail.Merge(m, src)
}
func (m *TxOutDetail) XXX_Size() int {
	return m.Size()
}
func (m *TxOutDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TxOutDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TxOutDetail proto.InternalMessageInfo

type isTxOutDetail_Appendix interface {
	isTxOutDetail_Appendix()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TxOutDetail_TokenIssueInfo struct {
	TokenIssueInfo *TokenIssueInfo `protobuf:"bytes,6,opt,name=token_issue_info,json=tokenIssueInfo,proto3,oneof"`
}
type TxOutDetail_TokenTransferInfo struct {
	TokenTransferInfo *TokenTransferInfo `protobuf:"bytes,7,opt,name=token_transfer_info,json=tokenTransferInfo,proto3,oneof"`
}
type TxOutDetail_SplitContractInfo struct {
	SplitContractInfo *SplitContractInfo `protobuf:"bytes,8,opt,name=split_contract_info,json=splitContractInfo,proto3,oneof"`
}

func (*TxOutDetail_TokenIssueInfo) isTxOutDetail_Appendix()    {}
func (*TxOutDetail_TokenTransferInfo) isTxOutDetail_Appendix() {}
func (*TxOutDetail_SplitContractInfo) isTxOutDetail_Appendix() {}

func (m *TxOutDetail) GetAppendix() isTxOutDetail_Appendix {
	if m != nil {
		return m.Appendix
	}
	return nil
}

func (m *TxOutDetail) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *TxOutDetail) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *TxOutDetail) GetScriptPubKey() string {
	if m != nil {
		return m.ScriptPubKey
	}
	return ""
}

func (m *TxOutDetail) GetScriptDisasm() string {
	if m != nil {
		return m.ScriptDisasm
	}
	return ""
}

func (m *TxOutDetail) GetType() TxOutDetail_TxOutType {
	if m != nil {
		return m.Type
	}
	return TxOutDetail_unknown
}

func (m *TxOutDetail) GetTokenIssueInfo() *TokenIssueInfo {
	if x, ok := m.GetAppendix().(*TxOutDetail_TokenIssueInfo); ok {
		return x.TokenIssueInfo
	}
	return nil
}

func (m *TxOutDetail) GetTokenTransferInfo() *TokenTransferInfo {
	if x, ok := m.GetAppendix().(*TxOutDetail_TokenTransferInfo); ok {
		return x.TokenTransferInfo
	}
	return nil
}

func (m *TxOutDetail) GetSplitContractInfo() *SplitContractInfo {
	if x, ok := m.GetAppendix().(*TxOutDetail_SplitContractInfo); ok {
		return x.SplitContractInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TxOutDetail) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TxOutDetail_OneofMarshaler, _TxOutDetail_OneofUnmarshaler, _TxOutDetail_OneofSizer, []interface{}{
		(*TxOutDetail_TokenIssueInfo)(nil),
		(*TxOutDetail_TokenTransferInfo)(nil),
		(*TxOutDetail_SplitContractInfo)(nil),
	}
}

func _TxOutDetail_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TxOutDetail)
	// appendix
	switch x := m.Appendix.(type) {
	case *TxOutDetail_TokenIssueInfo:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TokenIssueInfo); err != nil {
			return err
		}
	case *TxOutDetail_TokenTransferInfo:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TokenTransferInfo); err != nil {
			return err
		}
	case *TxOutDetail_SplitContractInfo:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SplitContractInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TxOutDetail.Appendix has unexpected type %T", x)
	}
	return nil
}

func _TxOutDetail_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TxOutDetail)
	switch tag {
	case 6: // appendix.token_issue_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TokenIssueInfo)
		err := b.DecodeMessage(msg)
		m.Appendix = &TxOutDetail_TokenIssueInfo{msg}
		return true, err
	case 7: // appendix.token_transfer_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TokenTransferInfo)
		err := b.DecodeMessage(msg)
		m.Appendix = &TxOutDetail_TokenTransferInfo{msg}
		return true, err
	case 8: // appendix.split_contract_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SplitContractInfo)
		err := b.DecodeMessage(msg)
		m.Appendix = &TxOutDetail_SplitContractInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TxOutDetail_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TxOutDetail)
	// appendix
	switch x := m.Appendix.(type) {
	case *TxOutDetail_TokenIssueInfo:
		s := proto.Size(x.TokenIssueInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TxOutDetail_TokenTransferInfo:
		s := proto.Size(x.TokenTransferInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TxOutDetail_SplitContractInfo:
		s := proto.Size(x.SplitContractInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type BlockDetail struct {
	Version       int32       `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Height        uint32      `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TimeStamp     int64       `protobuf:"varint,3,opt,name=time_stamp,json=timeStamp,proto3" json:"time_stamp,omitempty"`
	Size_         uint32      `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	Hash          string      `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
	PrevBlockHash string      `protobuf:"bytes,6,opt,name=prev_block_hash,json=prevBlockHash,proto3" json:"prev_block_hash,omitempty"`
	CoinBase      string      `protobuf:"bytes,7,opt,name=coin_base,json=coinBase,proto3" json:"coin_base,omitempty"`
	Confirmed     bool        `protobuf:"varint,8,opt,name=confirmed,proto3" json:"confirmed,omitempty"`
	Signature     string      `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty"`
	Txs           []*TxDetail `protobuf:"bytes,10,rep,name=txs,proto3" json:"txs,omitempty"`
}

func (m *BlockDetail) Reset()         { *m = BlockDetail{} }
func (m *BlockDetail) String() string { return proto.CompactTextString(m) }
func (*BlockDetail) ProtoMessage()    {}
func (*BlockDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{8}
}
func (m *BlockDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockDetail.Merge(m, src)
}
func (m *BlockDetail) XXX_Size() int {
	return m.Size()
}
func (m *BlockDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockDetail.DiscardUnknown(m)
}

var xxx_messageInfo_BlockDetail proto.InternalMessageInfo

func (m *BlockDetail) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BlockDetail) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BlockDetail) GetTimeStamp() int64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

func (m *BlockDetail) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *BlockDetail) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *BlockDetail) GetPrevBlockHash() string {
	if m != nil {
		return m.PrevBlockHash
	}
	return ""
}

func (m *BlockDetail) GetCoinBase() string {
	if m != nil {
		return m.CoinBase
	}
	return ""
}

func (m *BlockDetail) GetConfirmed() bool {
	if m != nil {
		return m.Confirmed
	}
	return false
}

func (m *BlockDetail) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *BlockDetail) GetTxs() []*TxDetail {
	if m != nil {
		return m.Txs
	}
	return nil
}

type TokenIssueInfo struct {
	TokenTag *TokenTag `protobuf:"bytes,1,opt,name=token_tag,json=tokenTag,proto3" json:"token_tag,omitempty"`
}

func (m *TokenIssueInfo) Reset()         { *m = TokenIssueInfo{} }
func (m *TokenIssueInfo) String() string { return proto.CompactTextString(m) }
func (*TokenIssueInfo) ProtoMessage()    {}
func (*TokenIssueInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{9}
}
func (m *TokenIssueInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenIssueInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenIssueInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenIssueInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenIssueInfo.Merge(m, src)
}
func (m *TokenIssueInfo) XXX_Size() int {
	return m.Size()
}
func (m *TokenIssueInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenIssueInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TokenIssueInfo proto.InternalMessageInfo

func (m *TokenIssueInfo) GetTokenTag() *TokenTag {
	if m != nil {
		return m.TokenTag
	}
	return nil
}

type SplitContractInfo struct {
	Addrs   []string `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"`
	Weights []uint64 `protobuf:"varint,2,rep,packed,name=weights,proto3" json:"weights,omitempty"`
}

func (m *SplitContractInfo) Reset()         { *m = SplitContractInfo{} }
func (m *SplitContractInfo) String() string { return proto.CompactTextString(m) }
func (*SplitContractInfo) ProtoMessage()    {}
func (*SplitContractInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{10}
}
func (m *SplitContractInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitContractInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitContractInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitContractInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitContractInfo.Merge(m, src)
}
func (m *SplitContractInfo) XXX_Size() int {
	return m.Size()
}
func (m *SplitContractInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitContractInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SplitContractInfo proto.InternalMessageInfo

func (m *SplitContractInfo) GetAddrs() []string {
	if m != nil {
		return m.Addrs
	}
	return nil
}

func (m *SplitContractInfo) GetWeights() []uint64 {
	if m != nil {
		return m.Weights
	}
	return nil
}

type TokenTransferInfo struct {
	TokenId string `protobuf:"bytes,1,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
}

func (m *TokenTransferInfo) Reset()         { *m = TokenTransferInfo{} }
func (m *TokenTransferInfo) String() string { return proto.CompactTextString(m) }
func (*TokenTransferInfo) ProtoMessage()    {}
func (*TokenTransferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_461bb3ac99194e85, []int{11}
}
func (m *TokenTransferInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenTransferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenTransferInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenTransferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenTransferInfo.Merge(m, src)
}
func (m *TokenTransferInfo) XXX_Size() int {
	return m.Size()
}
func (m *TokenTransferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenTransferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TokenTransferInfo proto.InternalMessageInfo

func (m *TokenTransferInfo) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

func init() {
	proto.RegisterEnum("rpcpb.ViewTxDetailResp_TxStatus", ViewTxDetailResp_TxStatus_name, ViewTxDetailResp_TxStatus_value)
	proto.RegisterEnum("rpcpb.TxOutDetail_TxOutType", TxOutDetail_TxOutType_name, TxOutDetail_TxOutType_value)
	proto.RegisterType((*ViewTxDetailReq)(nil), "rpcpb.ViewTxDetailReq")
	proto.RegisterType((*ViewTxDetailResp)(nil), "rpcpb.ViewTxDetailResp")
	proto.RegisterType((*ViewBlockDetailReq)(nil), "rpcpb.ViewBlockDetailReq")
	proto.RegisterType((*ViewBlockDetailResp)(nil), "rpcpb.ViewBlockDetailResp")
	proto.RegisterType((*ListenBlocksReq)(nil), "rpcpb.ListenBlocksReq")
	proto.RegisterType((*TxDetail)(nil), "rpcpb.TxDetail")
	proto.RegisterType((*TxInDetail)(nil), "rpcpb.TxInDetail")
	proto.RegisterType((*TxOutDetail)(nil), "rpcpb.TxOutDetail")
	proto.RegisterType((*BlockDetail)(nil), "rpcpb.BlockDetail")
	proto.RegisterType((*TokenIssueInfo)(nil), "rpcpb.TokenIssueInfo")
	proto.RegisterType((*SplitContractInfo)(nil), "rpcpb.SplitContractInfo")
	proto.RegisterType((*TokenTransferInfo)(nil), "rpcpb.TokenTransferInfo")
}

func init() { proto.RegisterFile("web.proto", fileDescriptor_461bb3ac99194e85) }

var fileDescriptor_461bb3ac99194e85 = []byte{
	// 1095 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4d, 0x6f, 0x23, 0x45,
	0x13, 0xce, 0xf8, 0x2b, 0x9e, 0x72, 0x6c, 0x8f, 0x7b, 0xdf, 0xcd, 0xce, 0x3a, 0x79, 0x2d, 0xef,
	0x2c, 0x5a, 0xac, 0x15, 0x4a, 0x16, 0x73, 0x41, 0x7b, 0x40, 0x24, 0xbb, 0x48, 0x09, 0x20, 0x58,
	0x75, 0x22, 0x10, 0xa7, 0x51, 0xdb, 0xd3, 0x71, 0x5a, 0xb6, 0x7b, 0x26, 0xd3, 0x3d, 0x4e, 0xcc,
	0x91, 0x5f, 0x00, 0xe2, 0xce, 0x1d, 0x7e, 0x03, 0x17, 0x6e, 0x1c, 0x57, 0xe2, 0xc2, 0x11, 0x25,
	0xfc, 0x10, 0xd4, 0x1f, 0xf6, 0x8e, 0xe3, 0x2c, 0x12, 0xb7, 0xa9, 0xa7, 0xaa, 0x9f, 0xee, 0xaa,
	0xae, 0x7a, 0x7a, 0xc0, 0xbd, 0xa4, 0x83, 0xbd, 0x24, 0x8d, 0x65, 0x8c, 0xca, 0x69, 0x32, 0x4c,
	0x06, 0xed, 0x96, 0x4c, 0x09, 0x17, 0x64, 0x28, 0x59, 0xcc, 0x8d, 0xa7, 0xbd, 0x3b, 0x8a, 0xe3,
	0xd1, 0x84, 0xee, 0x93, 0x84, 0xed, 0x13, 0xce, 0x63, 0x49, 0x94, 0x53, 0x18, 0x6f, 0x70, 0x04,
	0xcd, 0xaf, 0x18, 0xbd, 0x3c, 0xbd, 0x7a, 0x49, 0x25, 0x61, 0x13, 0x4c, 0x2f, 0x10, 0x82, 0xd2,
	0x39, 0x11, 0xe7, 0xbe, 0xd3, 0x75, 0x7a, 0x2e, 0xd6, 0xdf, 0xe8, 0x11, 0x6c, 0x89, 0x24, 0xa5,
	0x24, 0x0a, 0x45, 0x32, 0x61, 0xd2, 0x2f, 0x74, 0x9d, 0x5e, 0x15, 0xd7, 0x0c, 0x76, 0xa2, 0xa0,
	0xe0, 0xb7, 0x02, 0x78, 0xab, 0x54, 0x22, 0x51, 0x5c, 0xc3, 0x38, 0xa2, 0x9a, 0xab, 0x8c, 0xf5,
	0x37, 0xf2, 0x61, 0x73, 0x4a, 0x85, 0x20, 0x23, 0xaa, 0x69, 0x5c, 0xbc, 0x30, 0x95, 0x67, 0x46,
	0x53, 0xc1, 0x62, 0xee, 0x17, 0xf5, 0x82, 0x85, 0x89, 0xfe, 0x0f, 0x30, 0x98, 0xc4, 0xc3, 0x71,
	0x28, 0xd9, 0x94, 0xfa, 0xa5, 0xae, 0xd3, 0x2b, 0x62, 0x57, 0x23, 0xa7, 0x6c, 0x4a, 0xd5, 0xf1,
	0x8c, 0xfb, 0x9c, 0xb2, 0xd1, 0xb9, 0xf4, 0xcb, 0x5d, 0xa7, 0x57, 0xc7, 0x35, 0x8d, 0x1d, 0x69,
	0x08, 0x7d, 0x08, 0x15, 0x21, 0x89, 0xcc, 0x84, 0x5f, 0xe9, 0x3a, 0xbd, 0x46, 0xbf, 0xbb, 0xa7,
	0x2b, 0xb6, 0x77, 0xfb, 0xc8, 0x7b, 0xa7, 0x57, 0x27, 0x3a, 0x0e, 0xdb, 0x78, 0xf4, 0x2e, 0x54,
	0x22, 0xed, 0xf6, 0x37, 0xbb, 0x4e, 0xaf, 0xd6, 0x6f, 0xda, 0x95, 0xcb, 0x55, 0xd6, 0x1d, 0x7c,
	0x0c, 0xd5, 0xc5, 0x62, 0x54, 0x83, 0xcd, 0x8c, 0x8f, 0x79, 0x7c, 0xc9, 0xbd, 0x0d, 0x65, 0x24,
	0x94, 0x47, 0x8c, 0x8f, 0x3c, 0x47, 0x19, 0x31, 0x1f, 0x9e, 0x13, 0xc6, 0xbd, 0x02, 0xaa, 0x83,
	0x3b, 0x8c, 0xf9, 0x19, 0x4b, 0xa7, 0x34, 0xf2, 0x8a, 0x41, 0x0f, 0x90, 0x3a, 0xcf, 0xa1, 0x3a,
	0xf7, 0xbf, 0x5e, 0x48, 0x10, 0xc3, 0xbd, 0xb5, 0xc8, 0xff, 0x5c, 0xef, 0xa7, 0xcb, 0xcc, 0x8a,
	0x3a, 0x33, 0x64, 0x33, 0xcb, 0xb3, 0x2e, 0x92, 0x6b, 0x41, 0xf3, 0x73, 0x26, 0x24, 0xe5, 0xda,
	0x29, 0x30, 0xbd, 0x08, 0xc6, 0x2a, 0x5f, 0x13, 0x76, 0x67, 0xd3, 0x3c, 0x86, 0xe2, 0x8c, 0x71,
	0xbf, 0xd0, 0x2d, 0xf6, 0x6a, 0xfd, 0xd6, 0xb2, 0x6a, 0xc7, 0xdc, 0x52, 0x2b, 0x2f, 0x7a, 0x02,
	0xa5, 0x59, 0x9c, 0x49, 0xbf, 0xa8, 0xa3, 0xd0, 0x32, 0xea, 0xcb, 0x4c, 0xda, 0x30, 0xed, 0x0f,
	0x7e, 0x76, 0x00, 0xde, 0xac, 0x45, 0xcf, 0xa1, 0x99, 0xa4, 0x74, 0x16, 0xc6, 0x99, 0x0c, 0x6d,
	0x0e, 0xce, 0x4a, 0x0e, 0x79, 0x86, 0xba, 0x0a, 0x5d, 0x9a, 0xaa, 0x99, 0xc4, 0x30, 0x65, 0x89,
	0x0c, 0x05, 0x1b, 0xd9, 0x9a, 0xb8, 0x06, 0x39, 0x61, 0x23, 0xd4, 0x86, 0xaa, 0xa0, 0x17, 0x19,
	0xe5, 0x43, 0xaa, 0xeb, 0x52, 0xc7, 0x4b, 0x1b, 0xbd, 0x03, 0x8d, 0xe5, 0xb6, 0x49, 0xcc, 0xb8,
	0xd4, 0xbd, 0xe8, 0xe2, 0x2d, 0xbb, 0xc3, 0x2b, 0x85, 0x05, 0xbf, 0x96, 0xa0, 0x96, 0xdb, 0x5f,
	0x15, 0x87, 0x44, 0x51, 0xba, 0x28, 0x8e, 0xfa, 0x46, 0xff, 0x83, 0xf2, 0x8c, 0x4c, 0x32, 0x73,
	0x27, 0x25, 0x6c, 0x0c, 0xc5, 0x6f, 0x8f, 0x96, 0x64, 0x83, 0x70, 0x4c, 0xe7, 0xfa, 0x04, 0x2e,
	0xde, 0x32, 0xe8, 0xab, 0x6c, 0xf0, 0x19, 0x9d, 0xa3, 0xc7, 0x50, 0xb7, 0x51, 0x11, 0x13, 0x44,
	0x4c, 0x17, 0x87, 0x30, 0xe0, 0x4b, 0x8d, 0xa1, 0x67, 0x50, 0x92, 0xf3, 0x84, 0xea, 0x59, 0x68,
	0xf4, 0x77, 0xd7, 0xcb, 0x62, 0xbe, 0x4f, 0xe7, 0x09, 0xc5, 0x3a, 0x12, 0x1d, 0x80, 0x27, 0xe3,
	0x31, 0xe5, 0x21, 0x13, 0x22, 0xa3, 0x21, 0xe3, 0x67, 0xb1, 0x1e, 0x96, 0x5a, 0xff, 0xfe, 0x62,
	0xb5, 0x72, 0x1f, 0x2b, 0xef, 0x31, 0x3f, 0x8b, 0x8f, 0x36, 0x70, 0x43, 0xae, 0x20, 0xe8, 0x53,
	0xb8, 0x67, 0x28, 0xb4, 0x0e, 0x9d, 0xd1, 0xd4, 0xb0, 0x98, 0xc1, 0xf1, 0xf3, 0x2c, 0xa7, 0x36,
	0xc0, 0x12, 0xb5, 0xe4, 0x6d, 0x50, 0x71, 0x69, 0xb1, 0x09, 0x87, 0x31, 0x97, 0x29, 0x19, 0x4a,
	0xc3, 0x55, 0x5d, 0xe1, 0xd2, 0xda, 0xf3, 0xc2, 0x06, 0x2c, 0xb8, 0xc4, 0x6d, 0x30, 0xf8, 0xc9,
	0x01, 0x77, 0x99, 0xee, 0xea, 0x70, 0x6e, 0x03, 0x4a, 0xc8, 0x3c, 0x94, 0xb1, 0x2a, 0xf9, 0x98,
	0xce, 0x43, 0xd5, 0xbb, 0x9e, 0x83, 0x76, 0xe0, 0xc1, 0x3a, 0x1e, 0x0e, 0x27, 0x72, 0xe6, 0x15,
	0x50, 0x13, 0x6a, 0xb9, 0x52, 0x79, 0x45, 0x84, 0xa0, 0xb1, 0x9a, 0xb8, 0x57, 0x52, 0x18, 0xa7,
	0x97, 0x46, 0x31, 0x43, 0x75, 0xe9, 0x5e, 0x39, 0xb7, 0x9b, 0xbd, 0x41, 0xbd, 0x5b, 0xe5, 0x10,
	0xa0, 0x4a, 0x12, 0x2d, 0x12, 0x57, 0xc1, 0x2f, 0x05, 0xa8, 0xe5, 0x46, 0x30, 0x2f, 0x8b, 0xce,
	0xaa, 0x2c, 0x6e, 0x43, 0xc5, 0x2a, 0x5e, 0x41, 0x37, 0xaa, 0xb5, 0x54, 0x87, 0x2b, 0xa1, 0x0c,
	0x85, 0x24, 0xd3, 0x44, 0xb7, 0x50, 0x11, 0xbb, 0x0a, 0x39, 0x51, 0x80, 0xea, 0x47, 0xc1, 0xbe,
	0x35, 0x3a, 0x5a, 0xc7, 0xfa, 0x7b, 0x39, 0xc0, 0xe5, 0xdc, 0x00, 0x3f, 0xb1, 0x43, 0x66, 0xb5,
	0x55, 0xb9, 0x2b, 0xda, 0xad, 0x07, 0x4a, 0x1f, 0xf1, 0x48, 0xc5, 0xed, 0x28, 0x15, 0x63, 0x3c,
	0x1c, 0x10, 0x41, 0xf5, 0x5d, 0xbb, 0xb8, 0xaa, 0x80, 0x43, 0x22, 0x28, 0xda, 0xcd, 0x49, 0x9c,
	0xbe, 0xbc, 0x2a, 0x7e, 0x03, 0x28, 0xaf, 0x60, 0x23, 0x4e, 0x64, 0x96, 0x52, 0xdf, 0xb5, 0xa3,
	0xb8, 0x00, 0xd0, 0x23, 0x28, 0xca, 0x2b, 0xe1, 0x83, 0xd6, 0x86, 0x35, 0xdd, 0x55, 0xbe, 0xe0,
	0x23, 0x68, 0xac, 0x76, 0x25, 0x7a, 0x0f, 0x5c, 0x7b, 0x15, 0x64, 0x64, 0x45, 0xa1, 0xb9, 0xd2,
	0x79, 0x64, 0x84, 0xab, 0xd2, 0x7e, 0x05, 0x2f, 0xa0, 0xb5, 0xd6, 0x43, 0x6a, 0x38, 0xd5, 0x7d,
	0x09, 0xdf, 0xe9, 0x16, 0x7b, 0x2e, 0x36, 0x86, 0xba, 0x87, 0x4b, 0x5d, 0x5f, 0xa1, 0x35, 0xad,
	0x84, 0x17, 0x66, 0xb0, 0x07, 0xad, 0xb5, 0xa6, 0x46, 0x0f, 0xa1, 0x6a, 0x7b, 0x24, 0xb2, 0x93,
	0xbf, 0x69, 0xa6, 0x25, 0xea, 0xff, 0x50, 0x80, 0xca, 0xd7, 0x74, 0x70, 0x90, 0x30, 0xf4, 0x0d,
	0x6c, 0xe5, 0x9f, 0x20, 0xb4, 0x7d, 0xe7, 0xbb, 0x74, 0xd1, 0x7e, 0xf0, 0x96, 0xf7, 0x2a, 0xf0,
	0xbf, 0xfb, 0xe3, 0xef, 0x1f, 0x0b, 0x28, 0xa8, 0xef, 0xcf, 0xde, 0xdf, 0x97, 0x57, 0xfb, 0x46,
	0x0d, 0x9f, 0x3b, 0x4f, 0x11, 0x35, 0x6f, 0x7b, 0xbe, 0x95, 0x1e, 0xe6, 0x58, 0x56, 0x5f, 0x99,
	0x76, 0xfb, 0x6d, 0x2e, 0x91, 0x04, 0x3b, 0x7a, 0x8f, 0xfb, 0x81, 0xa7, 0xf6, 0xd0, 0xdd, 0x90,
	0xdb, 0xe6, 0x13, 0xb8, 0x6f, 0x5e, 0x86, 0x03, 0x1e, 0x61, 0x4a, 0xa2, 0x2f, 0xec, 0xfa, 0x65,
	0x2a, 0xb7, 0xde, 0x8d, 0xf6, 0x1d, 0xcf, 0xcc, 0x33, 0xe7, 0xd0, 0xff, 0xfd, 0xba, 0xe3, 0xbc,
	0xbe, 0xee, 0x38, 0x7f, 0x5d, 0x77, 0x9c, 0xef, 0x6f, 0x3a, 0x1b, 0xaf, 0x6f, 0x3a, 0x1b, 0x7f,
	0xde, 0x74, 0x36, 0x06, 0x15, 0xfd, 0xab, 0xf2, 0xc1, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x77,
	0xf2, 0x22, 0xba, 0xef, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WebApiClient is the client API for WebApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WebApiClient interface {
	ViewTxDetail(ctx context.Context, in *ViewTxDetailReq, opts ...grpc.CallOption) (*ViewTxDetailResp, error)
	ViewBlockDetail(ctx context.Context, in *ViewBlockDetailReq, opts ...grpc.CallOption) (*ViewBlockDetailResp, error)
	ListenAndReadNewBlock(ctx context.Context, in *ListenBlocksReq, opts ...grpc.CallOption) (WebApi_ListenAndReadNewBlockClient, error)
}

type webApiClient struct {
	cc *grpc.ClientConn
}

func NewWebApiClient(cc *grpc.ClientConn) WebApiClient {
	return &webApiClient{cc}
}

func (c *webApiClient) ViewTxDetail(ctx context.Context, in *ViewTxDetailReq, opts ...grpc.CallOption) (*ViewTxDetailResp, error) {
	out := new(ViewTxDetailResp)
	err := c.cc.Invoke(ctx, "/rpcpb.WebApi/ViewTxDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webApiClient) ViewBlockDetail(ctx context.Context, in *ViewBlockDetailReq, opts ...grpc.CallOption) (*ViewBlockDetailResp, error) {
	out := new(ViewBlockDetailResp)
	err := c.cc.Invoke(ctx, "/rpcpb.WebApi/ViewBlockDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webApiClient) ListenAndReadNewBlock(ctx context.Context, in *ListenBlocksReq, opts ...grpc.CallOption) (WebApi_ListenAndReadNewBlockClient, error) {
	stream, err := c.cc.NewStream(ctx, &_WebApi_serviceDesc.Streams[0], "/rpcpb.WebApi/ListenAndReadNewBlock", opts...)
	if err != nil {
		return nil, err
	}
	x := &webApiListenAndReadNewBlockClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WebApi_ListenAndReadNewBlockClient interface {
	Recv() (*BlockDetail, error)
	grpc.ClientStream
}

type webApiListenAndReadNewBlockClient struct {
	grpc.ClientStream
}

func (x *webApiListenAndReadNewBlockClient) Recv() (*BlockDetail, error) {
	m := new(BlockDetail)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// WebApiServer is the server API for WebApi service.
type WebApiServer interface {
	ViewTxDetail(context.Context, *ViewTxDetailReq) (*ViewTxDetailResp, error)
	ViewBlockDetail(context.Context, *ViewBlockDetailReq) (*ViewBlockDetailResp, error)
	ListenAndReadNewBlock(*ListenBlocksReq, WebApi_ListenAndReadNewBlockServer) error
}

func RegisterWebApiServer(s *grpc.Server, srv WebApiServer) {
	s.RegisterService(&_WebApi_serviceDesc, srv)
}

func _WebApi_ViewTxDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewTxDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebApiServer).ViewTxDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.WebApi/ViewTxDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebApiServer).ViewTxDetail(ctx, req.(*ViewTxDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebApi_ViewBlockDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewBlockDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebApiServer).ViewBlockDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.WebApi/ViewBlockDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebApiServer).ViewBlockDetail(ctx, req.(*ViewBlockDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebApi_ListenAndReadNewBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenBlocksReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WebApiServer).ListenAndReadNewBlock(m, &webApiListenAndReadNewBlockServer{stream})
}

type WebApi_ListenAndReadNewBlockServer interface {
	Send(*BlockDetail) error
	grpc.ServerStream
}

type webApiListenAndReadNewBlockServer struct {
	grpc.ServerStream
}

func (x *webApiListenAndReadNewBlockServer) Send(m *BlockDetail) error {
	return x.ServerStream.SendMsg(m)
}

var _WebApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpcpb.WebApi",
	HandlerType: (*WebApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ViewTxDetail",
			Handler:    _WebApi_ViewTxDetail_Handler,
		},
		{
			MethodName: "ViewBlockDetail",
			Handler:    _WebApi_ViewBlockDetail_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListenAndReadNewBlock",
			Handler:       _WebApi_ListenAndReadNewBlock_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "web.proto",
}

func (m *ViewTxDetailReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewTxDetailReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.SpreadSplit {
		dAtA[i] = 0x10
		i++
		if m.SpreadSplit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ViewTxDetailResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewTxDetailResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Version))
	}
	if m.BlockTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.BlockTime))
	}
	if m.BlockHeight != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.BlockHeight))
	}
	if m.Status != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Status))
	}
	if m.Detail != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Detail.Size()))
		n1, err1 := m.Detail.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	return i, nil
}

func (m *ViewBlockDetailReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewBlockDetailReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	return i, nil
}

func (m *ViewBlockDetailResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewBlockDetailResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Detail != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Detail.Size()))
		n2, err2 := m.Detail.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}

func (m *ListenBlocksReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListenBlocksReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if len(m.Vin) > 0 {
		for _, msg := range m.Vin {
			dAtA[i] = 0x12
			i++
			i = encodeVarintWeb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Vout) > 0 {
		for _, msg := range m.Vout {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintWeb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TxInDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxInDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PrevOutDetail != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.PrevOutDetail.Size()))
		n3, err3 := m.PrevOutDetail.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if len(m.ScriptSig) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.ScriptSig)))
		i += copy(dAtA[i:], m.ScriptSig)
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Sequence))
	}
	if len(m.PrevOutPoint) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.PrevOutPoint)))
		i += copy(dAtA[i:], m.PrevOutPoint)
	}
	return i, nil
}

func (m *TxOutDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxOutDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Value))
	}
	if len(m.ScriptPubKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.ScriptPubKey)))
		i += copy(dAtA[i:], m.ScriptPubKey)
	}
	if len(m.ScriptDisasm) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.ScriptDisasm)))
		i += copy(dAtA[i:], m.ScriptDisasm)
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Type))
	}
	if m.Appendix != nil {
		nn4, err4 := m.Appendix.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += nn4
	}
	return i, nil
}

func (m *TxOutDetail_TokenIssueInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TokenIssueInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.TokenIssueInfo.Size()))
		n5, err5 := m.TokenIssueInfo.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}
func (m *TxOutDetail_TokenTransferInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TokenTransferInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.TokenTransferInfo.Size()))
		n6, err6 := m.TokenTransferInfo.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	return i, nil
}
func (m *TxOutDetail_SplitContractInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SplitContractInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.SplitContractInfo.Size()))
		n7, err7 := m.SplitContractInfo.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	return i, nil
}
func (m *BlockDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Version))
	}
	if m.Height != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Height))
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.TimeStamp))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Size_))
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if len(m.PrevBlockHash) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.PrevBlockHash)))
		i += copy(dAtA[i:], m.PrevBlockHash)
	}
	if len(m.CoinBase) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.CoinBase)))
		i += copy(dAtA[i:], m.CoinBase)
	}
	if m.Confirmed {
		dAtA[i] = 0x40
		i++
		if m.Confirmed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if len(m.Txs) > 0 {
		for _, msg := range m.Txs {
			dAtA[i] = 0x52
			i++
			i = encodeVarintWeb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TokenIssueInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenIssueInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TokenTag != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.TokenTag.Size()))
		n8, err8 := m.TokenTag.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	return i, nil
}

func (m *SplitContractInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitContractInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Weights) > 0 {
		dAtA10 := make([]byte, len(m.Weights)*10)
		var j9 int
		for _, num := range m.Weights {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintWeb(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *TokenTransferInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenTransferInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TokenId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.TokenId)))
		i += copy(dAtA[i:], m.TokenId)
	}
	return i, nil
}

func encodeVarintWeb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ViewTxDetailReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.SpreadSplit {
		n += 2
	}
	return n
}

func (m *ViewTxDetailResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovWeb(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovWeb(uint64(m.Version))
	}
	if m.BlockTime != 0 {
		n += 1 + sovWeb(uint64(m.BlockTime))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovWeb(uint64(m.BlockHeight))
	}
	if m.Status != 0 {
		n += 1 + sovWeb(uint64(m.Status))
	}
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *ViewBlockDetailReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *ViewBlockDetailResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovWeb(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *ListenBlocksReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TxDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Vin) > 0 {
		for _, e := range m.Vin {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	if len(m.Vout) > 0 {
		for _, e := range m.Vout {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func (m *TxInDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevOutDetail != nil {
		l = m.PrevOutDetail.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.ScriptSig)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovWeb(uint64(m.Sequence))
	}
	l = len(m.PrevOutPoint)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *TxOutDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovWeb(uint64(m.Value))
	}
	l = len(m.ScriptPubKey)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.ScriptDisasm)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovWeb(uint64(m.Type))
	}
	if m.Appendix != nil {
		n += m.Appendix.Size()
	}
	return n
}

func (m *TxOutDetail_TokenIssueInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenIssueInfo != nil {
		l = m.TokenIssueInfo.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *TxOutDetail_TokenTransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenTransferInfo != nil {
		l = m.TokenTransferInfo.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *TxOutDetail_SplitContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SplitContractInfo != nil {
		l = m.SplitContractInfo.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}
func (m *BlockDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovWeb(uint64(m.Version))
	}
	if m.Height != 0 {
		n += 1 + sovWeb(uint64(m.Height))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovWeb(uint64(m.TimeStamp))
	}
	if m.Size_ != 0 {
		n += 1 + sovWeb(uint64(m.Size_))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.PrevBlockHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.CoinBase)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Confirmed {
		n += 2
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Txs) > 0 {
		for _, e := range m.Txs {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	return n
}

func (m *TokenIssueInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenTag != nil {
		l = m.TokenTag.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func (m *SplitContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			l = len(s)
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	if len(m.Weights) > 0 {
		l = 0
		for _, e := range m.Weights {
			l += sovWeb(uint64(e))
		}
		n += 1 + sovWeb(uint64(l)) + l
	}
	return n
}

func (m *TokenTransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenId)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	return n
}

func sovWeb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWeb(x uint64) (n int) {
	return sovWeb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ViewTxDetailReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewTxDetailReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewTxDetailReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpreadSplit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SpreadSplit = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewTxDetailResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewTxDetailResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewTxDetailResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ViewTxDetailResp_TxStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &TxDetail{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewBlockDetailReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewBlockDetailReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewBlockDetailReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewBlockDetailResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewBlockDetailResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewBlockDetailResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &BlockDetail{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListenBlocksReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListenBlocksReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListenBlocksReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vin = append(m.Vin, &TxInDetail{})
			if err := m.Vin[len(m.Vin)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vout = append(m.Vout, &TxOutDetail{})
			if err := m.Vout[len(m.Vout)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxInDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxInDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxInDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevOutDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevOutDetail == nil {
				m.PrevOutDetail = &TxOutDetail{}
			}
			if err := m.PrevOutDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptSig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptSig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevOutPoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevOutPoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxOutDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxOutDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxOutDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptDisasm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptDisasm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TxOutDetail_TxOutType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIssueInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TokenIssueInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Appendix = &TxOutDetail_TokenIssueInfo{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenTransferInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TokenTransferInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Appendix = &TxOutDetail_TokenTransferInfo{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitContractInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SplitContractInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Appendix = &TxOutDetail_SplitContractInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevBlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevBlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirmed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Confirmed = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, &TxDetail{})
			if err := m.Txs[len(m.Txs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenIssueInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenIssueInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenIssueInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenTag == nil {
				m.TokenTag = &TokenTag{}
			}
			if err := m.TokenTag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitContractInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitContractInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitContractInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Weights = append(m.Weights, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWeb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthWeb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Weights) == 0 {
					m.Weights = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Weights = append(m.Weights, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenTransferInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenTransferInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenTransferInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWeb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWeb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthWeb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWeb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthWeb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWeb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWeb   = fmt.Errorf("proto: integer overflow")
)
