// Copyright (c) 2018 ContentBox Authors.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package p2p

import (
	"bytes"
	"crypto/rand"
	"fmt"
	"io/ioutil"
	"testing"

	"github.com/facebookgo/ensure"
	"github.com/golang/snappy"
	crypto "github.com/libp2p/go-libp2p-crypto"
	peer "github.com/libp2p/go-libp2p-peer"
)

func peerID() peer.ID {
	_, pubKey, _ := crypto.GenerateEd25519Key(rand.Reader)
	id, _ := peer.IDFromPublicKey(pubKey)
	return id
}

func TestRemoteMessage(t *testing.T) {
	msg := newMessageData(Mainnet, Ping, []byte{}, []byte{})
	peerID := peerID()

	remotemsg := &remoteMessage{message: msg, from: peerID}

	ensure.DeepEqual(t, remotemsg.Code(), uint32(Ping))
	ensure.DeepEqual(t, remotemsg.Body(), []byte{})
	ensure.DeepEqual(t, remotemsg.From(), peerID)
	ensure.Nil(t, remotemsg.check())
}

var tests = []struct {
	Magic uint32
	Code  uint32
	Extra []byte
	Body  []byte
}{
	{
		Magic: Mainnet,
		Code:  Ping,
		Extra: []byte{0x00, 0x01, 0x02, 0x03, 0x10, 0x11, 0x12, 0x13, 0x14},
		Body: []byte{
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
		},
	},
	{
		Magic: Mainnet,
		Code:  Ping,
		Extra: []byte{0x00, 0x01, 0x02, 0x03, 0x10, 0x11, 0x12, 0x13, 0x14},
		Body:  []byte{},
	},
	{
		Magic: Mainnet,
		Code:  Ping,
		Extra: []byte{
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
		},
		Body: []byte{0x00, 0x10, 0x20, 0x30},
	},
	{
		Magic: Testnet,
		Code:  TransactionMsg,
		Extra: nil,
		Body: []byte{
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
		},
	},
	{
		Magic: Mainnet,
		Code:  Pong,
		Extra: []byte{},
		Body:  []byte{0x00, 0x00, 0x10, 0x20, 0x40, 0x11, 0xff},
	},
	{
		Magic: Testnet,
		Code:  TransactionMsg,
		Extra: []byte{0x00, 0x00, 0x10, 0x20, 0x40, 0x11, 0xff},
		Body: []byte{
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
			0x00, 0x10, 0x20, 0x30, 0x40, 0x40, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff,
		},
	},
}

func equal(t *testing.T, msgActual *message, msgExpect *message) {
	ensure.DeepEqual(t, msgActual.body, msgExpect.body)
	ensure.DeepEqual(t, msgActual.code, msgExpect.code)
	ensure.DeepEqual(t, msgActual.magic, msgExpect.magic)
	ensure.DeepEqual(t, msgActual.dataChecksum, msgExpect.dataChecksum)
	ensure.DeepEqual(t, msgActual.dataLength, msgExpect.dataLength)
	if len(msgExpect.reserved) == 0 {
		ensure.DeepEqual(t, len(msgActual.reserved), 0) // in case nil and []byte{}
	} else {
		ensure.DeepEqual(t, msgActual.reserved, msgExpect.reserved)
	}
	ensure.Nil(t, msgActual.check()) // msg validation
}

func TestMessageUnmarshalError(t *testing.T) {
	test := tests[0]
	msg := newMessageData(test.Magic, test.Code, test.Extra, test.Body)

	msg.dataLength++
	data, err := msg.Marshal()
	ensure.Nil(t, err)
	msg2 := &message{}
	ensure.NotNil(t, msg2.Unmarshal(data))
}

func TestMessageMarshalAndUnmarshal(t *testing.T) {
	for _, test := range tests {
		msg := newMessageData(test.Magic, test.Code, test.Extra, test.Body)
		data, err := msg.Marshal()
		ensure.Nil(t, err)

		msg2 := &message{}
		ensure.Nil(t, msg2.Unmarshal(data))

		equal(t, msg2, msg)

		ensure.Nil(t, msg2.check()) // msg validation
	}
}

func TestMarshalAndUnmarshal(t *testing.T) {
	var buf bytes.Buffer
	for _, test := range tests {
		msg := newMessageData(test.Magic, test.Code, test.Extra, test.Body)
		data, _ := msg.Marshal()
		buf.Write(data)
	}

	for _, test := range tests {
		msg, err := readMessageData(&buf)
		ensure.Nil(t, err)

		msgExpected := newMessageData(test.Magic, test.Code, test.Extra, test.Body)
		equal(t, msg, msgExpected)
	}
}

func TestSnappyEncode(t *testing.T) {
	filename := "message.go"
	if contents, err := ioutil.ReadFile(filename); err == nil {
		fmt.Println(len(contents))
		got := snappy.Encode(nil, contents)
		fmt.Println(len(got))

		data, _ := snappy.Decode(nil, got)
		fmt.Println(len(string(data)))
	}
}
