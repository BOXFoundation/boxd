// Copyright (c) 2018 ContentBox Authors.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package types

import (
	"encoding/hex"
	"encoding/json"

	"github.com/BOXFoundation/boxd/core"
	corepb "github.com/BOXFoundation/boxd/core/pb"
	"github.com/BOXFoundation/boxd/crypto"
	conv "github.com/BOXFoundation/boxd/p2p/convert"
	proto "github.com/gogo/protobuf/proto"
)

//go:generate gencodec -type Log -field-override logMarshaling -out gen_log_json.go

// Log represents a contract log event. These events are generated by the LOG opcode and
// stored/indexed by the node.
type Log struct {
	// Consensus fields:
	// address of the contract that generated the event
	Address AddressHash `json:"address" gencodec:"required"`
	// list of topics provided by the contract.
	Topics []crypto.HashType `json:"topics" gencodec:"required"`
	// supplied by the contract, usually ABI-encoded
	Data []byte `json:"data" gencodec:"required"`

	// Derived fields. These fields are filled in by the node
	// but not secured by consensus.
	// block in which the transaction was included
	BlockNumber uint64 `json:"blockNumber"`
	// hash of the transaction
	TxHash crypto.HashType `json:"transactionHash" gencodec:"required"`
	// index of the transaction in the block
	TxIndex uint32 `json:"transactionIndex" gencodec:"required"`
	// hash of the block in which the transaction was included
	BlockHash crypto.HashType `json:"blockHash"`
	// index of the log in the block
	Index uint32 `json:"logIndex" gencodec:"required"`

	// The Removed field is true if this log was reverted due to a chain reorganisation.
	// You must pay attention to this field if you receive logs through a filter query.
	Removed bool `json:"removed"`
}

// MarshalJSON implements Log json marshaler interface
func (log *Log) MarshalJSON() ([]byte, error) {
	out := struct {
		Address     AddressHash       `json:"address"`
		Topics      []crypto.HashType `json:"topics"`
		Data        string            `json:"data"`
		BlockNumber uint64            `json:"blockNumber"`
		TxHash      crypto.HashType   `json:"transactionHash"`
		TxIndex     uint32            `json:"transactionIndex"`
		BlockHash   crypto.HashType   `json:"blockHash"`
		Index       uint32            `json:"logIndex"`
		Removed     bool              `json:"removed"`
	}{
		log.Address,
		log.Topics,
		hex.EncodeToString(log.Data),
		log.BlockNumber,
		log.TxHash,
		log.TxIndex,
		log.BlockHash,
		log.Index,
		log.Removed,
	}
	return json.Marshal(out)
}

func (log *Log) toHashLog() *hashLog {
	hashlog := new(hashLog)
	copy(hashlog.Address[:], log.Address[:])
	hashlog.Topics = make([]crypto.HashType, len(log.Topics))
	for i, topic := range log.Topics {
		hash := new(crypto.HashType)
		hashlog.Topics[i] = *hash
		copy(hashlog.Topics[i][:], topic[:])
	}
	copy(hashlog.Data[:], log.Data[:])
	return hashlog
}

type hashLog struct {
	Address AddressHash
	Topics  []crypto.HashType
	Data    []byte
}

var _ conv.Convertible = (*Log)(nil)
var _ conv.Serializable = (*Log)(nil)
var _ conv.Convertible = (*hashLog)(nil)
var _ conv.Serializable = (*hashLog)(nil)

// ToProtoMessage converts Receipt to proto message.
func (log *Log) ToProtoMessage() (proto.Message, error) {
	topics := [][]byte{}
	for _, topic := range log.Topics {
		topics = append(topics, topic.Bytes())
	}
	return &corepb.Log{
		Address:     log.Address[:],
		Topics:      topics,
		Data:        log.Data[:],
		BlockNumber: log.BlockNumber,
		TxHash:      log.TxHash[:],
		TxIndex:     log.TxIndex,
		Index:       log.Index,
		Removed:     log.Removed,
	}, nil
}

// FromProtoMessage converts proto message to Receipt.
func (log *Log) FromProtoMessage(message proto.Message) error {
	pblog, ok := message.(*corepb.Log)
	if !ok {
		return core.ErrInvalidLogProtoMessage
	}
	if message == nil {
		return core.ErrEmptyProtoMessage
	}

	copy(log.Address[:], pblog.Address[:])
	log.Topics = make([]crypto.HashType, len(pblog.Topics))
	for i, topic := range pblog.Topics {
		hash := new(crypto.HashType)
		log.Topics[i] = *hash
		copy(log.Topics[i][:], topic[:])
	}
	log.Data = make([]byte, len(pblog.Data))
	copy(log.Data, pblog.Data)
	log.BlockNumber = pblog.BlockNumber
	copy(log.TxHash[:], pblog.TxHash[:])
	log.TxIndex = pblog.TxIndex
	log.Index = pblog.Index
	log.Removed = pblog.Removed
	return nil
}

// Marshal method marshal Receipt object to binary
func (log *Log) Marshal() (data []byte, err error) {
	return conv.MarshalConvertible(log)
}

// Unmarshal method unmarshal binary data to Receipt object
func (log *Log) Unmarshal(data []byte) error {
	pblog := new(corepb.Log)
	if err := proto.Unmarshal(data, pblog); err != nil {
		return err
	}
	return log.FromProtoMessage(pblog)
}

// ToProtoMessage converts Receipt to proto message.
func (log *hashLog) ToProtoMessage() (proto.Message, error) {
	topics := [][]byte{}
	for _, topic := range log.Topics {
		topics = append(topics, topic.Bytes())
	}
	return &corepb.HashLog{
		Address: log.Address[:],
		Topics:  topics,
		Data:    log.Data,
	}, nil
}

// FromProtoMessage converts proto message to Receipt.
func (log *hashLog) FromProtoMessage(message proto.Message) error {
	pblog, ok := message.(*corepb.HashLog)
	if !ok {
		return core.ErrInvalidLogProtoMessage
	}
	if message == nil {
		return core.ErrEmptyProtoMessage
	}

	copy(log.Address[:], pblog.Address[:])
	log.Topics = make([]crypto.HashType, len(pblog.Topics))
	for i, topic := range pblog.Topics {
		hash := new(crypto.HashType)
		log.Topics[i] = *hash
		copy(log.Topics[i][:], topic[:])
	}
	log.Data = make([]byte, len(pblog.Data))
	copy(log.Data[:], pblog.Data[:])
	return nil
}

// Marshal method marshal Receipt object to binary
func (log *hashLog) Marshal() (data []byte, err error) {
	return conv.MarshalConvertible(log)
}

// Unmarshal method unmarshal binary data to Receipt object
func (log *hashLog) Unmarshal(data []byte) error {
	pblog := new(corepb.HashLog)
	if err := proto.Unmarshal(data, pblog); err != nil {
		return err
	}
	return log.FromProtoMessage(pblog)
}
